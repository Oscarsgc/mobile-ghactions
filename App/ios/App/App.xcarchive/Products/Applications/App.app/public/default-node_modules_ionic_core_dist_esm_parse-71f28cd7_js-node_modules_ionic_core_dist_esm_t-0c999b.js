"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["default-node_modules_ionic_core_dist_esm_parse-71f28cd7_js-node_modules_ionic_core_dist_esm_t-0c999b"],{

/***/ 9273:
/*!*************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/index-c4b11676.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "a": () => (/* binding */ printRequiredElementError),
/* harmony export */   "b": () => (/* binding */ printIonError),
/* harmony export */   "p": () => (/* binding */ printIonWarning)
/* harmony export */ });
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */

/**
 * Logs a warning to the console with an Ionic prefix
 * to indicate the library that is warning the developer.
 *
 * @param message - The string message to be logged to the console.
 */
const printIonWarning = (message, ...params) => {
  return console.warn(`[Ionic Warning]: ${message}`, ...params);
};
/*
 * Logs an error to the console with an Ionic prefix
 * to indicate the library that is warning the developer.
 *
 * @param message - The string message to be logged to the console.
 * @param params - Additional arguments to supply to the console.error.
 */


const printIonError = (message, ...params) => {
  return console.error(`[Ionic Error]: ${message}`, ...params);
};
/**
 * Prints an error informing developers that an implementation requires an element to be used
 * within a specific selector.
 *
 * @param el The web component element this is requiring the element.
 * @param targetSelectors The selector or selectors that were not found.
 */


const printRequiredElementError = (el, ...targetSelectors) => {
  return console.error(`<${el.tagName.toLowerCase()}> must be used inside ${targetSelectors.join(' or ')}.`);
};



/***/ }),

/***/ 1474:
/*!*************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/parse-71f28cd7.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "A": () => (/* binding */ getYearColumnData),
/* harmony export */   "B": () => (/* binding */ isMonthFirstLocale),
/* harmony export */   "C": () => (/* binding */ getTimeColumnsData),
/* harmony export */   "D": () => (/* binding */ isLocaleDayPeriodRTL),
/* harmony export */   "E": () => (/* binding */ getDaysOfWeek),
/* harmony export */   "F": () => (/* binding */ getMonthAndYear),
/* harmony export */   "G": () => (/* binding */ getDaysOfMonth),
/* harmony export */   "H": () => (/* binding */ generateMonths),
/* harmony export */   "I": () => (/* binding */ is24Hour),
/* harmony export */   "J": () => (/* binding */ getLocalizedTime),
/* harmony export */   "K": () => (/* binding */ getMonthAndDay),
/* harmony export */   "L": () => (/* binding */ formatValue),
/* harmony export */   "M": () => (/* binding */ getNextYear),
/* harmony export */   "N": () => (/* binding */ getPreviousYear),
/* harmony export */   "O": () => (/* binding */ clampDate),
/* harmony export */   "P": () => (/* binding */ parseAmPm),
/* harmony export */   "Q": () => (/* binding */ calculateHourFromAMPM),
/* harmony export */   "R": () => (/* binding */ getLocalizedDateTime),
/* harmony export */   "S": () => (/* binding */ getMonthDayAndYear),
/* harmony export */   "a": () => (/* binding */ getDay),
/* harmony export */   "b": () => (/* binding */ isAfter),
/* harmony export */   "c": () => (/* binding */ isSameDay),
/* harmony export */   "d": () => (/* binding */ getPreviousMonth),
/* harmony export */   "e": () => (/* binding */ getNextMonth),
/* harmony export */   "f": () => (/* binding */ getToday),
/* harmony export */   "g": () => (/* binding */ generateDayAriaLabel),
/* harmony export */   "h": () => (/* binding */ getPartsFromCalendarDay),
/* harmony export */   "i": () => (/* binding */ isBefore),
/* harmony export */   "j": () => (/* binding */ getEndOfWeek),
/* harmony export */   "k": () => (/* binding */ getStartOfWeek),
/* harmony export */   "l": () => (/* binding */ getPreviousDay),
/* harmony export */   "m": () => (/* binding */ getNextDay),
/* harmony export */   "n": () => (/* binding */ getPreviousWeek),
/* harmony export */   "o": () => (/* binding */ getNextWeek),
/* harmony export */   "p": () => (/* binding */ parseDate),
/* harmony export */   "q": () => (/* binding */ parseMinParts),
/* harmony export */   "r": () => (/* binding */ parseMaxParts),
/* harmony export */   "s": () => (/* binding */ convertToArrayOfNumbers),
/* harmony export */   "t": () => (/* binding */ convertDataToISO),
/* harmony export */   "u": () => (/* binding */ getNumDaysInMonth),
/* harmony export */   "v": () => (/* binding */ validateParts),
/* harmony export */   "w": () => (/* binding */ warnIfValueOutOfBounds),
/* harmony export */   "x": () => (/* binding */ getCombinedDateColumnData),
/* harmony export */   "y": () => (/* binding */ getMonthColumnData),
/* harmony export */   "z": () => (/* binding */ getDayColumnData)
/* harmony export */ });
/* harmony import */ var _index_c4b11676_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-c4b11676.js */ 9273);
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */

/**
 * Returns true if the selected day is equal to the reference day
 */

const isSameDay = (baseParts, compareParts) => {
  return baseParts.month === compareParts.month && baseParts.day === compareParts.day && baseParts.year === compareParts.year;
};
/**
 * Returns true is the selected day is before the reference day.
 */


const isBefore = (baseParts, compareParts) => {
  return !!(baseParts.year < compareParts.year || baseParts.year === compareParts.year && baseParts.month < compareParts.month || baseParts.year === compareParts.year && baseParts.month === compareParts.month && baseParts.day !== null && baseParts.day < compareParts.day);
};
/**
 * Returns true is the selected day is after the reference day.
 */


const isAfter = (baseParts, compareParts) => {
  return !!(baseParts.year > compareParts.year || baseParts.year === compareParts.year && baseParts.month > compareParts.month || baseParts.year === compareParts.year && baseParts.month === compareParts.month && baseParts.day !== null && baseParts.day > compareParts.day);
};

const warnIfValueOutOfBounds = (value, min, max) => {
  const valueArray = Array.isArray(value) ? value : [value];

  for (const val of valueArray) {
    if (min !== undefined && isBefore(val, min) || max !== undefined && isAfter(val, max)) {
      (0,_index_c4b11676_js__WEBPACK_IMPORTED_MODULE_0__.p)('The value provided to ion-datetime is out of bounds.\n\n' + `Min: ${JSON.stringify(min)}\n` + `Max: ${JSON.stringify(max)}\n` + `Value: ${JSON.stringify(value)}`);
      break;
    }
  }
};
/**
 * Determines if given year is a
 * leap year. Returns `true` if year
 * is a leap year. Returns `false`
 * otherwise.
 */


const isLeapYear = year => {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};

const is24Hour = (locale, hourCycle) => {
  /**
   * If developer has explicitly enabled h23 time
   * then return early and do not look at the system default.
   */
  if (hourCycle !== undefined) {
    return hourCycle === 'h23';
  }
  /**
   * If hourCycle was not specified, check the locale
   * that is set on the user's device. We first check the
   * Intl.DateTimeFormat hourCycle option as developers can encode this
   * option into the locale string. Example: `en-US-u-hc-h23`
   */


  const formatted = new Intl.DateTimeFormat(locale, {
    hour: 'numeric'
  });
  const options = formatted.resolvedOptions();

  if (options.hourCycle !== undefined) {
    return options.hourCycle === 'h23';
  }
  /**
   * If hourCycle is not specified (either through lack
   * of browser support or locale information) then fall
   * back to this slower hourCycle check.
   */


  const date = new Date('5/18/2021 00:00');
  const parts = formatted.formatToParts(date);
  const hour = parts.find(p => p.type === 'hour');

  if (!hour) {
    throw new Error('Hour value not found from DateTimeFormat');
  }

  return hour.value === '00';
};
/**
 * Given a date object, returns the number
 * of days in that month.
 * Month value begin at 1, not 0.
 * i.e. January = month 1.
 */


const getNumDaysInMonth = (month, year) => {
  return month === 4 || month === 6 || month === 9 || month === 11 ? 30 : month === 2 ? isLeapYear(year) ? 29 : 28 : 31;
};
/**
 * Certain locales display month then year while
 * others display year then month.
 * We can use Intl.DateTimeFormat to determine
 * the ordering for each locale.
 * The formatOptions param can be used to customize
 * which pieces of a date to compare against the month
 * with. For example, some locales render dd/mm/yyyy
 * while others render mm/dd/yyyy. This function can be
 * used for variations of the same "month first" check.
 */


const isMonthFirstLocale = (locale, formatOptions = {
  month: 'numeric',
  year: 'numeric'
}) => {
  /**
   * By setting month and year we guarantee that only
   * month, year, and literal (slashes '/', for example)
   * values are included in the formatToParts results.
   *
   * The ordering of the parts will be determined by
   * the locale. So if the month is the first value,
   * then we know month should be shown first. If the
   * year is the first value, then we know year should be shown first.
   *
   * This ordering can be controlled by customizing the locale property.
   */
  const parts = new Intl.DateTimeFormat(locale, formatOptions).formatToParts(new Date());
  return parts[0].type === 'month';
};
/**
 * Determines if the given locale formats the day period (am/pm) to the
 * left or right of the hour.
 * @param locale The locale to check.
 * @returns `true` if the locale formats the day period to the left of the hour.
 */


const isLocaleDayPeriodRTL = locale => {
  const parts = new Intl.DateTimeFormat(locale, {
    hour: 'numeric'
  }).formatToParts(new Date());
  return parts[0].type === 'dayPeriod';
};

const twoDigit = val => {
  return ('0' + (val !== undefined ? Math.abs(val) : '0')).slice(-2);
};

const fourDigit = val => {
  return ('000' + (val !== undefined ? Math.abs(val) : '0')).slice(-4);
};

function convertDataToISO(data) {
  if (Array.isArray(data)) {
    return data.map(parts => convertDataToISO(parts));
  } // https://www.w3.org/TR/NOTE-datetime


  let rtn = '';

  if (data.year !== undefined) {
    // YYYY
    rtn = fourDigit(data.year);

    if (data.month !== undefined) {
      // YYYY-MM
      rtn += '-' + twoDigit(data.month);

      if (data.day !== undefined) {
        // YYYY-MM-DD
        rtn += '-' + twoDigit(data.day);

        if (data.hour !== undefined) {
          // YYYY-MM-DDTHH:mm:SS
          rtn += `T${twoDigit(data.hour)}:${twoDigit(data.minute)}:00`;

          if (data.tzOffset === undefined) {
            // YYYY-MM-DDTHH:mm:SSZ
            rtn += 'Z';
          } else {
            // YYYY-MM-DDTHH:mm:SS+/-HH:mm
            rtn += (data.tzOffset > 0 ? '+' : '-') + twoDigit(Math.floor(Math.abs(data.tzOffset / 60))) + ':' + twoDigit(data.tzOffset % 60);
          }
        }
      }
    }
  } else if (data.hour !== undefined) {
    // HH:mm
    rtn = twoDigit(data.hour) + ':' + twoDigit(data.minute);
  }

  return rtn;
}
/**
 * Converts an 12 hour value to 24 hours.
 */


const convert12HourTo24Hour = (hour, ampm) => {
  if (ampm === undefined) {
    return hour;
  }
  /**
   * If AM and 12am
   * then return 00:00.
   * Otherwise just return
   * the hour since it is
   * already in 24 hour format.
   */


  if (ampm === 'am') {
    if (hour === 12) {
      return 0;
    }

    return hour;
  }
  /**
   * If PM and 12pm
   * just return 12:00
   * since it is already
   * in 24 hour format.
   * Otherwise add 12 hours
   * to the time.
   */


  if (hour === 12) {
    return 12;
  }

  return hour + 12;
};

const getStartOfWeek = refParts => {
  const {
    dayOfWeek
  } = refParts;

  if (dayOfWeek === null || dayOfWeek === undefined) {
    throw new Error('No day of week provided');
  }

  return subtractDays(refParts, dayOfWeek);
};

const getEndOfWeek = refParts => {
  const {
    dayOfWeek
  } = refParts;

  if (dayOfWeek === null || dayOfWeek === undefined) {
    throw new Error('No day of week provided');
  }

  return addDays(refParts, 6 - dayOfWeek);
};

const getNextDay = refParts => {
  return addDays(refParts, 1);
};

const getPreviousDay = refParts => {
  return subtractDays(refParts, 1);
};

const getPreviousWeek = refParts => {
  return subtractDays(refParts, 7);
};

const getNextWeek = refParts => {
  return addDays(refParts, 7);
};
/**
 * Given datetime parts, subtract
 * numDays from the date.
 * Returns a new DatetimeParts object
 * Currently can only go backward at most 1 month.
 */


const subtractDays = (refParts, numDays) => {
  const {
    month,
    day,
    year
  } = refParts;

  if (day === null) {
    throw new Error('No day provided');
  }

  const workingParts = {
    month,
    day,
    year
  };
  workingParts.day = day - numDays;
  /**
   * If wrapping to previous month
   * update days and decrement month
   */

  if (workingParts.day < 1) {
    workingParts.month -= 1;
  }
  /**
   * If moving to previous year, reset
   * month to December and decrement year
   */


  if (workingParts.month < 1) {
    workingParts.month = 12;
    workingParts.year -= 1;
  }
  /**
   * Determine how many days are in the current
   * month
   */


  if (workingParts.day < 1) {
    const daysInMonth = getNumDaysInMonth(workingParts.month, workingParts.year);
    /**
     * Take num days in month and add the
     * number of underflow days. This number will
     * be negative.
     * Example: 1 week before Jan 2, 2021 is
     * December 26, 2021 so:
     * 2 - 7 = -5
     * 31 + (-5) = 26
     */

    workingParts.day = daysInMonth + workingParts.day;
  }

  return workingParts;
};
/**
 * Given datetime parts, add
 * numDays to the date.
 * Returns a new DatetimeParts object
 * Currently can only go forward at most 1 month.
 */


const addDays = (refParts, numDays) => {
  const {
    month,
    day,
    year
  } = refParts;

  if (day === null) {
    throw new Error('No day provided');
  }

  const workingParts = {
    month,
    day,
    year
  };
  const daysInMonth = getNumDaysInMonth(month, year);
  workingParts.day = day + numDays;
  /**
   * If wrapping to next month
   * update days and increment month
   */

  if (workingParts.day > daysInMonth) {
    workingParts.day -= daysInMonth;
    workingParts.month += 1;
  }
  /**
   * If moving to next year, reset
   * month to January and increment year
   */


  if (workingParts.month > 12) {
    workingParts.month = 1;
    workingParts.year += 1;
  }

  return workingParts;
};
/**
 * Given DatetimeParts, generate the previous month.
 */


const getPreviousMonth = refParts => {
  /**
   * If current month is January, wrap backwards
   *  to December of the previous year.
   */
  const month = refParts.month === 1 ? 12 : refParts.month - 1;
  const year = refParts.month === 1 ? refParts.year - 1 : refParts.year;
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;
  return {
    month,
    year,
    day
  };
};
/**
 * Given DatetimeParts, generate the next month.
 */


const getNextMonth = refParts => {
  /**
   * If current month is December, wrap forwards
   *  to January of the next year.
   */
  const month = refParts.month === 12 ? 1 : refParts.month + 1;
  const year = refParts.month === 12 ? refParts.year + 1 : refParts.year;
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;
  return {
    month,
    year,
    day
  };
};

const changeYear = (refParts, yearDelta) => {
  const month = refParts.month;
  const year = refParts.year + yearDelta;
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;
  return {
    month,
    year,
    day
  };
};
/**
 * Given DatetimeParts, generate the previous year.
 */


const getPreviousYear = refParts => {
  return changeYear(refParts, -1);
};
/**
 * Given DatetimeParts, generate the next year.
 */


const getNextYear = refParts => {
  return changeYear(refParts, 1);
};
/**
 * If PM, then internal value should
 * be converted to 24-hr time.
 * Does not apply when public
 * values are already 24-hr time.
 */


const getInternalHourValue = (hour, use24Hour, ampm) => {
  if (use24Hour) {
    return hour;
  }

  return convert12HourTo24Hour(hour, ampm);
};
/**
 * Unless otherwise stated, all month values are
 * 1 indexed instead of the typical 0 index in JS Date.
 * Example:
 *   January = Month 0 when using JS Date
 *   January = Month 1 when using this datetime util
 */

/**
 * Given the current datetime parts and a new AM/PM value
 * calculate what the hour should be in 24-hour time format.
 * Used when toggling the AM/PM segment since we store our hours
 * in 24-hour time format internally.
 */


const calculateHourFromAMPM = (currentParts, newAMPM) => {
  const {
    ampm: currentAMPM,
    hour
  } = currentParts;
  let newHour = hour;
  /**
   * If going from AM --> PM, need to update the
   *
   */

  if (currentAMPM === 'am' && newAMPM === 'pm') {
    newHour = convert12HourTo24Hour(newHour, 'pm');
    /**
     * If going from PM --> AM
     */
  } else if (currentAMPM === 'pm' && newAMPM === 'am') {
    newHour = Math.abs(newHour - 12);
  }

  return newHour;
};
/**
 * Updates parts to ensure that month and day
 * values are valid. For days that do not exist,
 * the closest valid day is used.
 */


const validateParts = parts => {
  const {
    month,
    day,
    year
  } = parts;
  const partsCopy = Object.assign({}, parts);
  const numDays = getNumDaysInMonth(month, year);
  /**
   * If the max number of days
   * is greater than the day we want
   * to set, update the DatetimeParts
   * day field to be the max days.
   */

  if (day !== null && numDays < day) {
    partsCopy.day = numDays;
  }

  return partsCopy;
};

const getFormattedDayPeriod = dayPeriod => {
  if (dayPeriod === undefined) {
    return '';
  }

  return dayPeriod.toUpperCase();
};

const getLocalizedTime = (locale, refParts, use24Hour) => {
  if (refParts.hour === undefined || refParts.minute === undefined) {
    return 'Invalid Time';
  }

  return new Intl.DateTimeFormat(locale, {
    hour: 'numeric',
    minute: 'numeric',
    timeZone: 'UTC',

    /**
     * We use hourCycle here instead of hour12 due to:
     * https://bugs.chromium.org/p/chromium/issues/detail?id=1347316&q=hour12&can=2
     */
    hourCycle: use24Hour ? 'h23' : 'h12'
  }).format(new Date(convertDataToISO(Object.assign(Object.assign({}, refParts), {
    // TODO: FW-1831 will remove the need to manually set the tzOffset to undefined
    tzOffset: undefined
  }))));
};
/**
 * Adds padding to a time value so
 * that it is always 2 digits.
 */


const addTimePadding = value => {
  const valueToString = value.toString();

  if (valueToString.length > 1) {
    return valueToString;
  }

  return `0${valueToString}`;
};
/**
 * Formats 24 hour times so that
 * it always has 2 digits. For
 * 12 hour times it ensures that
 * hour 0 is formatted as '12'.
 */


const getFormattedHour = (hour, use24Hour) => {
  if (use24Hour) {
    return addTimePadding(hour);
  }
  /**
   * If using 12 hour
   * format, make sure hour
   * 0 is formatted as '12'.
   */


  if (hour === 0) {
    return '12';
  }

  return hour.toString();
};
/**
 * Generates an aria-label to be read by screen readers
 * given a local, a date, and whether or not that date is
 * today's date.
 */


const generateDayAriaLabel = (locale, today, refParts) => {
  if (refParts.day === null) {
    return null;
  }
  /**
   * MM/DD/YYYY will return midnight in the user's timezone.
   */


  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);
  const labelString = new Intl.DateTimeFormat(locale, {
    weekday: 'long',
    month: 'long',
    day: 'numeric',
    timeZone: 'UTC'
  }).format(date);
  /**
   * If date is today, prepend "Today" so screen readers indicate
   * that the date is today.
   */

  return today ? `Today, ${labelString}` : labelString;
};
/**
 * Gets the day of the week, month, and day
 * Used for the header in MD mode.
 */


const getMonthAndDay = (locale, refParts) => {
  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);
  return new Intl.DateTimeFormat(locale, {
    weekday: 'short',
    month: 'short',
    day: 'numeric',
    timeZone: 'UTC'
  }).format(date);
};
/**
 * Given a locale and a date object,
 * return a formatted string that includes
 * the month name and full year.
 * Example: May 2021
 */


const getMonthAndYear = (locale, refParts) => {
  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);
  return new Intl.DateTimeFormat(locale, {
    month: 'long',
    year: 'numeric',
    timeZone: 'UTC'
  }).format(date);
};
/**
 * Given a locale and a date object,
 * return a formatted string that includes
 * the short month, numeric day, and full year.
 * Example: Apr 22, 2021
 */


const getMonthDayAndYear = (locale, refParts) => {
  return getLocalizedDateTime(locale, refParts, {
    month: 'short',
    day: 'numeric',
    year: 'numeric'
  });
};
/**
 * Given a locale and a date object,
 * return a formatted string that includes
 * the numeric day.
 * Note: Some languages will add literal characters
 * to the end. This function removes those literals.
 * Example: 29
 */


const getDay = (locale, refParts) => {
  return getLocalizedDateTimeParts(locale, refParts, {
    day: 'numeric'
  }).find(obj => obj.type === 'day').value;
};
/**
 * Given a locale and a date object,
 * return a formatted string that includes
 * the numeric year.
 * Example: 2022
 */


const getYear = (locale, refParts) => {
  return getLocalizedDateTime(locale, refParts, {
    year: 'numeric'
  });
};

const getNormalizedDate = refParts => {
  const timeString = refParts.hour !== undefined && refParts.minute !== undefined ? ` ${refParts.hour}:${refParts.minute}` : '';
  return new Date(`${refParts.month}/${refParts.day}/${refParts.year}${timeString} GMT+0000`);
};
/**
 * Given a locale, DatetimeParts, and options
 * format the DatetimeParts according to the options
 * and locale combination. This returns a string. If
 * you want an array of the individual pieces
 * that make up the localized date string, use
 * getLocalizedDateTimeParts.
 */


const getLocalizedDateTime = (locale, refParts, options) => {
  const date = getNormalizedDate(refParts);
  return getDateTimeFormat(locale, options).format(date);
};
/**
 * Given a locale, DatetimeParts, and options
 * format the DatetimeParts according to the options
 * and locale combination. This returns an array of
 * each piece of the date.
 */


const getLocalizedDateTimeParts = (locale, refParts, options) => {
  const date = getNormalizedDate(refParts);
  return getDateTimeFormat(locale, options).formatToParts(date);
};
/**
 * Wrapper function for Intl.DateTimeFormat.
 * Allows developers to apply an allowed format to DatetimeParts.
 * This function also has built in safeguards for older browser bugs
 * with Intl.DateTimeFormat.
 */


const getDateTimeFormat = (locale, options) => {
  return new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, options), {
    timeZone: 'UTC'
  }));
};
/**
 * Gets a localized version of "Today"
 * Falls back to "Today" in English for
 * browsers that do not support RelativeTimeFormat.
 */


const getTodayLabel = locale => {
  if ('RelativeTimeFormat' in Intl) {
    const label = new Intl.RelativeTimeFormat(locale, {
      numeric: 'auto'
    }).format(0, 'day');
    return label.charAt(0).toUpperCase() + label.slice(1);
  } else {
    return 'Today';
  }
};
/**
 * When calling toISOString(), the browser
 * will convert the date to UTC time by either adding
 * or subtracting the time zone offset.
 * To work around this, we need to either add
 * or subtract the time zone offset to the Date
 * object prior to calling toISOString().
 * This allows us to get an ISO string
 * that is in the user's time zone.
 *
 * Example:
 * Time zone offset is 240
 * Meaning: The browser needs to add 240 minutes
 * to the Date object to get UTC time.
 * What Ionic does: We subtract 240 minutes
 * from the Date object. The browser then adds
 * 240 minutes in toISOString(). The result
 * is a time that is in the user's time zone
 * and not UTC.
 *
 * Note: Some timezones include minute adjustments
 * such as 30 or 45 minutes. This is why we use setMinutes
 * instead of setHours.
 * Example: India Standard Time
 * Timezone offset: -330 = -5.5 hours.
 *
 * List of timezones with 30 and 45 minute timezones:
 * https://www.timeanddate.com/time/time-zones-interesting.html
 */


const removeDateTzOffset = date => {
  const tzOffset = date.getTimezoneOffset();
  date.setMinutes(date.getMinutes() - tzOffset);
  return date;
};

const DATE_AM = removeDateTzOffset(new Date('2022T01:00'));
const DATE_PM = removeDateTzOffset(new Date('2022T13:00'));
/**
 * Formats the locale's string representation of the day period (am/pm) for a given
 * ref parts day period.
 *
 * @param locale The locale to format the day period in.
 * @param value The date string, in ISO format.
 * @returns The localized day period (am/pm) representation of the given value.
 */

const getLocalizedDayPeriod = (locale, dayPeriod) => {
  const date = dayPeriod === 'am' ? DATE_AM : DATE_PM;
  const localizedDayPeriod = new Intl.DateTimeFormat(locale, {
    hour: 'numeric',
    timeZone: 'UTC'
  }).formatToParts(date).find(part => part.type === 'dayPeriod');

  if (localizedDayPeriod) {
    return localizedDayPeriod.value;
  }

  return getFormattedDayPeriod(dayPeriod);
};
/**
 * Formats the datetime's value to a string, for use in the native input.
 *
 * @param value The value to format, either an ISO string or an array thereof.
 */


const formatValue = value => {
  return Array.isArray(value) ? value.join(',') : value;
};
/**
 * Returns the current date as
 * an ISO string in the user's
 * time zone.
 */


const getToday = () => {
  /**
   * ion-datetime intentionally does not
   * parse time zones/do automatic time zone
   * conversion when accepting user input.
   * However when we get today's date string,
   * we want it formatted relative to the user's
   * time zone.
   *
   * When calling toISOString(), the browser
   * will convert the date to UTC time by either adding
   * or subtracting the time zone offset.
   * To work around this, we need to either add
   * or subtract the time zone offset to the Date
   * object prior to calling toISOString().
   * This allows us to get an ISO string
   * that is in the user's time zone.
   */
  return removeDateTzOffset(new Date()).toISOString();
};

const minutes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59];
const hour12 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
const hour23 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];
/**
 * Given a locale and a mode,
 * return an array with formatted days
 * of the week. iOS should display days
 * such as "Mon" or "Tue".
 * MD should display days such as "M"
 * or "T".
 */

const getDaysOfWeek = (locale, mode, firstDayOfWeek = 0) => {
  /**
   * Nov 1st, 2020 starts on a Sunday.
   * ion-datetime assumes weeks start on Sunday,
   * but is configurable via `firstDayOfWeek`.
   */
  const weekdayFormat = mode === 'ios' ? 'short' : 'narrow';
  const intl = new Intl.DateTimeFormat(locale, {
    weekday: weekdayFormat
  });
  const startDate = new Date('11/01/2020');
  const daysOfWeek = [];
  /**
   * For each day of the week,
   * get the day name.
   */

  for (let i = firstDayOfWeek; i < firstDayOfWeek + 7; i++) {
    const currentDate = new Date(startDate);
    currentDate.setDate(currentDate.getDate() + i);
    daysOfWeek.push(intl.format(currentDate));
  }

  return daysOfWeek;
};
/**
 * Returns an array containing all of the
 * days in a month for a given year. Values are
 * aligned with a week calendar starting on
 * the firstDayOfWeek value (Sunday by default)
 * using null values.
 */


const getDaysOfMonth = (month, year, firstDayOfWeek) => {
  const numDays = getNumDaysInMonth(month, year);
  const firstOfMonth = new Date(`${month}/1/${year}`).getDay();
  /**
   * To get the first day of the month aligned on the correct
   * day of the week, we need to determine how many "filler" days
   * to generate. These filler days as empty/disabled buttons
   * that fill the space of the days of the week before the first
   * of the month.
   *
   * There are two cases here:
   *
   * 1. If firstOfMonth = 4, firstDayOfWeek = 0 then the offset
   * is (4 - (0 + 1)) = 3. Since the offset loop goes from 0 to 3 inclusive,
   * this will generate 4 filler days (0, 1, 2, 3), and then day of week 4 will have
   * the first day of the month.
   *
   * 2. If firstOfMonth = 2, firstDayOfWeek = 4 then the offset
   * is (6 - (4 - 2)) = 4. Since the offset loop goes from 0 to 4 inclusive,
   * this will generate 5 filler days (0, 1, 2, 3, 4), and then day of week 5 will have
   * the first day of the month.
   */

  const offset = firstOfMonth >= firstDayOfWeek ? firstOfMonth - (firstDayOfWeek + 1) : 6 - (firstDayOfWeek - firstOfMonth);
  let days = [];

  for (let i = 1; i <= numDays; i++) {
    days.push({
      day: i,
      dayOfWeek: (offset + i) % 7
    });
  }

  for (let i = 0; i <= offset; i++) {
    days = [{
      day: null,
      dayOfWeek: null
    }, ...days];
  }

  return days;
};
/**
 * Given a local, reference datetime parts and option
 * max/min bound datetime parts, calculate the acceptable
 * hour and minute values according to the bounds and locale.
 */


const generateTime = (refParts, hourCycle = 'h12', minParts, maxParts, hourValues, minuteValues) => {
  const use24Hour = hourCycle === 'h23';
  let processedHours = use24Hour ? hour23 : hour12;
  let processedMinutes = minutes;
  let isAMAllowed = true;
  let isPMAllowed = true;

  if (hourValues) {
    processedHours = processedHours.filter(hour => hourValues.includes(hour));
  }

  if (minuteValues) {
    processedMinutes = processedMinutes.filter(minute => minuteValues.includes(minute));
  }

  if (minParts) {
    /**
     * If ref day is the same as the
     * minimum allowed day, filter hour/minute
     * values according to min hour and minute.
     */
    if (isSameDay(refParts, minParts)) {
      /**
       * Users may not always set the hour/minute for
       * min value (i.e. 2021-06-02) so we should allow
       * all hours/minutes in that case.
       */
      if (minParts.hour !== undefined) {
        processedHours = processedHours.filter(hour => {
          const convertedHour = refParts.ampm === 'pm' ? (hour + 12) % 24 : hour;
          return (use24Hour ? hour : convertedHour) >= minParts.hour;
        });
        isAMAllowed = minParts.hour < 13;
      }

      if (minParts.minute !== undefined) {
        /**
         * The minimum minute range should not be enforced when
         * the hour is greater than the min hour.
         *
         * For example with a minimum range of 09:30, users
         * should be able to select 10:00-10:29 and beyond.
         */
        let isPastMinHour = false;

        if (minParts.hour !== undefined && refParts.hour !== undefined) {
          if (refParts.hour > minParts.hour) {
            isPastMinHour = true;
          }
        }

        processedMinutes = processedMinutes.filter(minute => {
          if (isPastMinHour) {
            return true;
          }

          return minute >= minParts.minute;
        });
      }
      /**
       * If ref day is before minimum
       * day do not render any hours/minute values
       */

    } else if (isBefore(refParts, minParts)) {
      processedHours = [];
      processedMinutes = [];
      isAMAllowed = isPMAllowed = false;
    }
  }

  if (maxParts) {
    /**
     * If ref day is the same as the
     * maximum allowed day, filter hour/minute
     * values according to max hour and minute.
     */
    if (isSameDay(refParts, maxParts)) {
      /**
       * Users may not always set the hour/minute for
       * max value (i.e. 2021-06-02) so we should allow
       * all hours/minutes in that case.
       */
      if (maxParts.hour !== undefined) {
        processedHours = processedHours.filter(hour => {
          const convertedHour = refParts.ampm === 'pm' ? (hour + 12) % 24 : hour;
          return (use24Hour ? hour : convertedHour) <= maxParts.hour;
        });
        isPMAllowed = maxParts.hour >= 13;
      }

      if (maxParts.minute !== undefined && refParts.hour === maxParts.hour) {
        // The available minutes should only be filtered when the hour is the same as the max hour.
        // For example if the max hour is 10:30 and the current hour is 10:00,
        // users should be able to select 00-30 minutes.
        // If the current hour is 09:00, users should be able to select 00-60 minutes.
        processedMinutes = processedMinutes.filter(minute => minute <= maxParts.minute);
      }
      /**
       * If ref day is after minimum
       * day do not render any hours/minute values
       */

    } else if (isAfter(refParts, maxParts)) {
      processedHours = [];
      processedMinutes = [];
      isAMAllowed = isPMAllowed = false;
    }
  }

  return {
    hours: processedHours,
    minutes: processedMinutes,
    am: isAMAllowed,
    pm: isPMAllowed
  };
};
/**
 * Given DatetimeParts, generate the previous,
 * current, and and next months.
 */


const generateMonths = refParts => {
  return [getPreviousMonth(refParts), {
    month: refParts.month,
    year: refParts.year,
    day: refParts.day
  }, getNextMonth(refParts)];
};

const getMonthColumnData = (locale, refParts, minParts, maxParts, monthValues, formatOptions = {
  month: 'long'
}) => {
  const {
    year
  } = refParts;
  const months = [];

  if (monthValues !== undefined) {
    let processedMonths = monthValues;

    if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.month) !== undefined) {
      processedMonths = processedMonths.filter(month => month <= maxParts.month);
    }

    if ((minParts === null || minParts === void 0 ? void 0 : minParts.month) !== undefined) {
      processedMonths = processedMonths.filter(month => month >= minParts.month);
    }

    processedMonths.forEach(processedMonth => {
      const date = new Date(`${processedMonth}/1/${year} GMT+0000`);
      const monthString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      months.push({
        text: monthString,
        value: processedMonth
      });
    });
  } else {
    const maxMonth = maxParts && maxParts.year === year ? maxParts.month : 12;
    const minMonth = minParts && minParts.year === year ? minParts.month : 1;

    for (let i = minMonth; i <= maxMonth; i++) {
      /**
       *
       * There is a bug on iOS 14 where
       * Intl.DateTimeFormat takes into account
       * the local timezone offset when formatting dates.
       *
       * Forcing the timezone to 'UTC' fixes the issue. However,
       * we should keep this workaround as it is safer. In the event
       * this breaks in another browser, we will not be impacted
       * because all dates will be interpreted in UTC.
       *
       * Example:
       * new Intl.DateTimeFormat('en-US', { month: 'long' }).format(new Date('Sat Apr 01 2006 00:00:00 GMT-0400 (EDT)')) // "March"
       * new Intl.DateTimeFormat('en-US', { month: 'long', timeZone: 'UTC' }).format(new Date('Sat Apr 01 2006 00:00:00 GMT-0400 (EDT)')) // "April"
       *
       * In certain timezones, iOS 14 shows the wrong
       * date for .toUTCString(). To combat this, we
       * force all of the timezones to GMT+0000 (UTC).
       *
       * Example:
       * Time Zone: Central European Standard Time
       * new Date('1/1/1992').toUTCString() // "Tue, 31 Dec 1991 23:00:00 GMT"
       * new Date('1/1/1992 GMT+0000').toUTCString() // "Wed, 01 Jan 1992 00:00:00 GMT"
       */
      const date = new Date(`${i}/1/${year} GMT+0000`);
      const monthString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      months.push({
        text: monthString,
        value: i
      });
    }
  }

  return months;
};
/**
 * Returns information regarding
 * selectable dates (i.e 1st, 2nd, 3rd, etc)
 * within a reference month.
 * @param locale The locale to format the date with
 * @param refParts The reference month/year to generate dates for
 * @param minParts The minimum bound on the date that can be returned
 * @param maxParts The maximum bound on the date that can be returned
 * @param dayValues The allowed date values
 * @returns Date data to be used in ion-picker-column-internal
 */


const getDayColumnData = (locale, refParts, minParts, maxParts, dayValues, formatOptions = {
  day: 'numeric'
}) => {
  const {
    month,
    year
  } = refParts;
  const days = [];
  /**
   * If we have max/min bounds that in the same
   * month/year as the refParts, we should
   * use the define day as the max/min day.
   * Otherwise, fallback to the max/min days in a month.
   */

  const numDaysInMonth = getNumDaysInMonth(month, year);
  const maxDay = (maxParts === null || maxParts === void 0 ? void 0 : maxParts.day) !== null && (maxParts === null || maxParts === void 0 ? void 0 : maxParts.day) !== undefined && maxParts.year === year && maxParts.month === month ? maxParts.day : numDaysInMonth;
  const minDay = (minParts === null || minParts === void 0 ? void 0 : minParts.day) !== null && (minParts === null || minParts === void 0 ? void 0 : minParts.day) !== undefined && minParts.year === year && minParts.month === month ? minParts.day : 1;

  if (dayValues !== undefined) {
    let processedDays = dayValues;
    processedDays = processedDays.filter(day => day >= minDay && day <= maxDay);
    processedDays.forEach(processedDay => {
      const date = new Date(`${month}/${processedDay}/${year} GMT+0000`);
      const dayString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      days.push({
        text: dayString,
        value: processedDay
      });
    });
  } else {
    for (let i = minDay; i <= maxDay; i++) {
      const date = new Date(`${month}/${i}/${year} GMT+0000`);
      const dayString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      days.push({
        text: dayString,
        value: i
      });
    }
  }

  return days;
};

const getYearColumnData = (locale, refParts, minParts, maxParts, yearValues) => {
  var _a, _b;

  let processedYears = [];

  if (yearValues !== undefined) {
    processedYears = yearValues;

    if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.year) !== undefined) {
      processedYears = processedYears.filter(year => year <= maxParts.year);
    }

    if ((minParts === null || minParts === void 0 ? void 0 : minParts.year) !== undefined) {
      processedYears = processedYears.filter(year => year >= minParts.year);
    }
  } else {
    const {
      year
    } = refParts;
    const maxYear = (_a = maxParts === null || maxParts === void 0 ? void 0 : maxParts.year) !== null && _a !== void 0 ? _a : year;
    const minYear = (_b = minParts === null || minParts === void 0 ? void 0 : minParts.year) !== null && _b !== void 0 ? _b : year - 100;

    for (let i = maxYear; i >= minYear; i--) {
      processedYears.push(i);
    }
  }

  return processedYears.map(year => ({
    text: getYear(locale, {
      year,
      month: refParts.month,
      day: refParts.day
    }),
    value: year
  }));
};
/**
 * Given a starting date and an upper bound,
 * this functions returns an array of all
 * month objects in that range.
 */


const getAllMonthsInRange = (currentParts, maxParts) => {
  if (currentParts.month === maxParts.month && currentParts.year === maxParts.year) {
    return [currentParts];
  }

  return [currentParts, ...getAllMonthsInRange(getNextMonth(currentParts), maxParts)];
};
/**
 * Creates and returns picker items
 * that represent the days in a month.
 * Example: "Thu, Jun 2"
 */


const getCombinedDateColumnData = (locale, todayParts, minParts, maxParts, dayValues, monthValues) => {
  let items = [];
  let parts = [];
  /**
   * Get all month objects from the min date
   * to the max date. Note: Do not use getMonthColumnData
   * as that function only generates dates within a
   * single year.
   */

  let months = getAllMonthsInRange(minParts, maxParts);
  /**
   * Filter out any disallowed month values.
   */

  if (monthValues) {
    months = months.filter(({
      month
    }) => monthValues.includes(month));
  }
  /**
   * Get all of the days in the month.
   * From there, generate an array where
   * each item has the month, date, and day
   * of work as the text.
   */


  months.forEach(monthObject => {
    const referenceMonth = {
      month: monthObject.month,
      day: null,
      year: monthObject.year
    };
    const monthDays = getDayColumnData(locale, referenceMonth, minParts, maxParts, dayValues, {
      month: 'short',
      day: 'numeric',
      weekday: 'short'
    });
    const dateParts = [];
    const dateColumnItems = [];
    monthDays.forEach(dayObject => {
      const isToday = isSameDay(Object.assign(Object.assign({}, referenceMonth), {
        day: dayObject.value
      }), todayParts);
      /**
       * Today's date should read as "Today" (localized)
       * not the actual date string
       */

      dateColumnItems.push({
        text: isToday ? getTodayLabel(locale) : dayObject.text,
        value: `${referenceMonth.year}-${referenceMonth.month}-${dayObject.value}`
      });
      /**
       * When selecting a date in the wheel picker
       * we need access to the raw datetime parts data.
       * The picker column only accepts values of
       * type string or number, so we need to return
       * two sets of data: A data set to be passed
       * to the picker column, and a data set to
       * be used to reference the raw data when
       * updating the picker column value.
       */

      dateParts.push({
        month: referenceMonth.month,
        year: referenceMonth.year,
        day: dayObject.value
      });
    });
    parts = [...parts, ...dateParts];
    items = [...items, ...dateColumnItems];
  });
  return {
    parts,
    items
  };
};

const getTimeColumnsData = (locale, refParts, hourCycle, minParts, maxParts, allowedHourValues, allowedMinuteVaues) => {
  const use24Hour = is24Hour(locale, hourCycle);
  const {
    hours,
    minutes,
    am,
    pm
  } = generateTime(refParts, use24Hour ? 'h23' : 'h12', minParts, maxParts, allowedHourValues, allowedMinuteVaues);
  const hoursItems = hours.map(hour => {
    return {
      text: getFormattedHour(hour, use24Hour),
      value: getInternalHourValue(hour, use24Hour, refParts.ampm)
    };
  });
  const minutesItems = minutes.map(minute => {
    return {
      text: addTimePadding(minute),
      value: minute
    };
  });
  const dayPeriodItems = [];

  if (am && !use24Hour) {
    dayPeriodItems.push({
      text: getLocalizedDayPeriod(locale, 'am'),
      value: 'am'
    });
  }

  if (pm && !use24Hour) {
    dayPeriodItems.push({
      text: getLocalizedDayPeriod(locale, 'pm'),
      value: 'pm'
    });
  }

  return {
    minutesData: minutesItems,
    hoursData: hoursItems,
    dayPeriodData: dayPeriodItems
  };
};

const ISO_8601_REGEXP = // eslint-disable-next-line no-useless-escape
/^(\d{4}|[+\-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/; // eslint-disable-next-line no-useless-escape

const TIME_REGEXP = /^((\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/;
/**
 * Use to convert a string of comma separated numbers or
 * an array of numbers, and clean up any user input
 */

const convertToArrayOfNumbers = input => {
  if (input === undefined) {
    return;
  }

  let processedInput = input;

  if (typeof input === 'string') {
    // convert the string to an array of strings
    // auto remove any whitespace and [] characters
    processedInput = input.replace(/\[|\]|\s/g, '').split(',');
  }

  let values;

  if (Array.isArray(processedInput)) {
    // ensure each value is an actual number in the returned array
    values = processedInput.map(num => parseInt(num, 10)).filter(isFinite);
  } else {
    values = [processedInput];
  }

  return values;
};
/**
 * Extracts date information
 * from a .calendar-day element
 * into DatetimeParts.
 */


const getPartsFromCalendarDay = el => {
  return {
    month: parseInt(el.getAttribute('data-month'), 10),
    day: parseInt(el.getAttribute('data-day'), 10),
    year: parseInt(el.getAttribute('data-year'), 10),
    dayOfWeek: parseInt(el.getAttribute('data-day-of-week'), 10)
  };
};

function parseDate(val) {
  if (Array.isArray(val)) {
    return val.map(valStr => parseDate(valStr));
  } // manually parse IS0 cuz Date.parse cannot be trusted
  // ISO 8601 format: 1994-12-15T13:47:20Z


  let parse = null;

  if (val != null && val !== '') {
    // try parsing for just time first, HH:MM
    parse = TIME_REGEXP.exec(val);

    if (parse) {
      // adjust the array so it fits nicely with the datetime parse
      parse.unshift(undefined, undefined);
      parse[2] = parse[3] = undefined;
    } else {
      // try parsing for full ISO datetime
      parse = ISO_8601_REGEXP.exec(val);
    }
  }

  if (parse === null) {
    // wasn't able to parse the ISO datetime
    return undefined;
  } // ensure all the parse values exist with at least 0


  for (let i = 1; i < 8; i++) {
    parse[i] = parse[i] !== undefined ? parseInt(parse[i], 10) : undefined;
  }

  let tzOffset = 0;

  if (parse[9] && parse[10]) {
    // hours
    tzOffset = parseInt(parse[10], 10) * 60;

    if (parse[11]) {
      // minutes
      tzOffset += parseInt(parse[11], 10);
    }

    if (parse[9] === '-') {
      // + or -
      tzOffset *= -1;
    }
  } // can also get second and millisecond from parse[6] and parse[7] if needed


  return {
    year: parse[1],
    month: parse[2],
    day: parse[3],
    hour: parse[4],
    minute: parse[5],
    tzOffset,
    ampm: parse[4] < 12 ? 'am' : 'pm'
  };
}

const clampDate = (dateParts, minParts, maxParts) => {
  if (minParts && isBefore(dateParts, minParts)) {
    return minParts;
  } else if (maxParts && isAfter(dateParts, maxParts)) {
    return maxParts;
  }

  return dateParts;
};
/**
 * Parses an hour and returns if the value is in the morning (am) or afternoon (pm).
 * @param hour The hour to format, should be 0-23
 * @returns `pm` if the hour is greater than or equal to 12, `am` if less than 12.
 */


const parseAmPm = hour => {
  return hour >= 12 ? 'pm' : 'am';
};
/**
 * Takes a max date string and creates a DatetimeParts
 * object, filling in any missing information.
 * For example, max="2012" would fill in the missing
 * month, day, hour, and minute information.
 */


const parseMaxParts = (max, todayParts) => {
  const {
    month,
    day,
    year,
    hour,
    minute
  } = parseDate(max);
  /**
   * When passing in `max` or `min`, developers
   * can pass in any ISO-8601 string. This means
   * that not all of the date/time fields are defined.
   * For example, passing max="2012" is valid even though
   * there is no month, day, hour, or minute data.
   * However, all of this data is required when clamping the date
   * so that the correct initial value can be selected. As a result,
   * we need to fill in any omitted data with the min or max values.
   */

  const yearValue = year !== null && year !== void 0 ? year : todayParts.year;
  const monthValue = month !== null && month !== void 0 ? month : 12;
  return {
    month: monthValue,
    day: day !== null && day !== void 0 ? day : getNumDaysInMonth(monthValue, yearValue),

    /**
     * Passing in "HH:mm" is a valid ISO-8601
     * string, so we just default to the current year
     * in this case.
     */
    year: yearValue,
    hour: hour !== null && hour !== void 0 ? hour : 23,
    minute: minute !== null && minute !== void 0 ? minute : 59
  };
};
/**
 * Takes a min date string and creates a DatetimeParts
 * object, filling in any missing information.
 * For example, min="2012" would fill in the missing
 * month, day, hour, and minute information.
 */


const parseMinParts = (min, todayParts) => {
  const {
    month,
    day,
    year,
    hour,
    minute
  } = parseDate(min);
  /**
   * When passing in `max` or `min`, developers
   * can pass in any ISO-8601 string. This means
   * that not all of the date/time fields are defined.
   * For example, passing max="2012" is valid even though
   * there is no month, day, hour, or minute data.
   * However, all of this data is required when clamping the date
   * so that the correct initial value can be selected. As a result,
   * we need to fill in any omitted data with the min or max values.
   */

  return {
    month: month !== null && month !== void 0 ? month : 1,
    day: day !== null && day !== void 0 ? day : 1,

    /**
     * Passing in "HH:mm" is a valid ISO-8601
     * string, so we just default to the current year
     * in this case.
     */
    year: year !== null && year !== void 0 ? year : todayParts.year,
    hour: hour !== null && hour !== void 0 ? hour : 0,
    minute: minute !== null && minute !== void 0 ? minute : 0
  };
};



/***/ }),

/***/ 320:
/*!*************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/theme-7670341c.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "c": () => (/* binding */ createColorClasses),
/* harmony export */   "g": () => (/* binding */ getClassMap),
/* harmony export */   "h": () => (/* binding */ hostContext),
/* harmony export */   "o": () => (/* binding */ openURL)
/* harmony export */ });
/* harmony import */ var _Users_oscar_sgc_Desktop_Sample_App_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 1670);


/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const hostContext = (selector, el) => {
  return el.closest(selector) !== null;
};
/**
 * Create the mode and color classes for the component based on the classes passed in
 */


const createColorClasses = (color, cssClassMap) => {
  return typeof color === 'string' && color.length > 0 ? Object.assign({
    'ion-color': true,
    [`ion-color-${color}`]: true
  }, cssClassMap) : cssClassMap;
};

const getClassList = classes => {
  if (classes !== undefined) {
    const array = Array.isArray(classes) ? classes : classes.split(' ');
    return array.filter(c => c != null).map(c => c.trim()).filter(c => c !== '');
  }

  return [];
};

const getClassMap = classes => {
  const map = {};
  getClassList(classes).forEach(c => map[c] = true);
  return map;
};

const SCHEME = /^[a-z][a-z0-9+\-.]*:/;

const openURL = /*#__PURE__*/function () {
  var _ref = (0,_Users_oscar_sgc_Desktop_Sample_App_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (url, ev, direction, animation) {
    if (url != null && url[0] !== '#' && !SCHEME.test(url)) {
      const router = document.querySelector('ion-router');

      if (router) {
        if (ev != null) {
          ev.preventDefault();
        }

        return router.push(url, direction, animation);
      }
    }

    return false;
  });

  return function openURL(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmYXVsdC1ub2RlX21vZHVsZXNfaW9uaWNfY29yZV9kaXN0X2VzbV9wYXJzZS03MWYyOGNkN19qcy1ub2RlX21vZHVsZXNfaW9uaWNfY29yZV9kaXN0X2VzbV90LTBjOTk5Yi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUEsZUFBZSxHQUFHLENBQUNDLE9BQUQsRUFBVSxHQUFHQyxNQUFiLEtBQXdCO0VBQzlDLE9BQU9DLE9BQU8sQ0FBQ0MsSUFBUixDQUFjLG9CQUFtQkgsT0FBUSxFQUF6QyxFQUE0QyxHQUFHQyxNQUEvQyxDQUFQO0FBQ0QsQ0FGRDtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNRyxhQUFhLEdBQUcsQ0FBQ0osT0FBRCxFQUFVLEdBQUdDLE1BQWIsS0FBd0I7RUFDNUMsT0FBT0MsT0FBTyxDQUFDRyxLQUFSLENBQWUsa0JBQWlCTCxPQUFRLEVBQXhDLEVBQTJDLEdBQUdDLE1BQTlDLENBQVA7QUFDRCxDQUZEO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1LLHlCQUF5QixHQUFHLENBQUNDLEVBQUQsRUFBSyxHQUFHQyxlQUFSLEtBQTRCO0VBQzVELE9BQU9OLE9BQU8sQ0FBQ0csS0FBUixDQUFlLElBQUdFLEVBQUUsQ0FBQ0UsT0FBSCxDQUFXQyxXQUFYLEVBQXlCLHlCQUF3QkYsZUFBZSxDQUFDRyxJQUFoQixDQUFxQixNQUFyQixDQUE2QixHQUFoRyxDQUFQO0FBQ0QsQ0FGRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQSxNQUFNSSxTQUFTLEdBQUcsQ0FBQ0MsU0FBRCxFQUFZQyxZQUFaLEtBQTZCO0VBQzdDLE9BQVFE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UEosT0FBTztJQUFBO0VBQUE7QUFBQSxHQUFiIiwic291cmNlcyI6WyIuL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS9pbmRleC1jNGIxMTY3Ni5qcyIsIi4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtL3BhcnNlLTcxZjI4Y2Q3LmpzIiwiLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20vdGhlbWUtNzY3MDM0MWMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbi8qKlxuICogTG9ncyBhIHdhcm5pbmcgdG8gdGhlIGNvbnNvbGUgd2l0aCBhbiBJb25pYyBwcmVmaXhcbiAqIHRvIGluZGljYXRlIHRoZSBsaWJyYXJ5IHRoYXQgaXMgd2FybmluZyB0aGUgZGV2ZWxvcGVyLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIHN0cmluZyBtZXNzYWdlIHRvIGJlIGxvZ2dlZCB0byB0aGUgY29uc29sZS5cbiAqL1xuY29uc3QgcHJpbnRJb25XYXJuaW5nID0gKG1lc3NhZ2UsIC4uLnBhcmFtcykgPT4ge1xuICByZXR1cm4gY29uc29sZS53YXJuKGBbSW9uaWMgV2FybmluZ106ICR7bWVzc2FnZX1gLCAuLi5wYXJhbXMpO1xufTtcbi8qXG4gKiBMb2dzIGFuIGVycm9yIHRvIHRoZSBjb25zb2xlIHdpdGggYW4gSW9uaWMgcHJlZml4XG4gKiB0byBpbmRpY2F0ZSB0aGUgbGlicmFyeSB0aGF0IGlzIHdhcm5pbmcgdGhlIGRldmVsb3Blci5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBzdHJpbmcgbWVzc2FnZSB0byBiZSBsb2dnZWQgdG8gdGhlIGNvbnNvbGUuXG4gKiBAcGFyYW0gcGFyYW1zIC0gQWRkaXRpb25hbCBhcmd1bWVudHMgdG8gc3VwcGx5IHRvIHRoZSBjb25zb2xlLmVycm9yLlxuICovXG5jb25zdCBwcmludElvbkVycm9yID0gKG1lc3NhZ2UsIC4uLnBhcmFtcykgPT4ge1xuICByZXR1cm4gY29uc29sZS5lcnJvcihgW0lvbmljIEVycm9yXTogJHttZXNzYWdlfWAsIC4uLnBhcmFtcyk7XG59O1xuLyoqXG4gKiBQcmludHMgYW4gZXJyb3IgaW5mb3JtaW5nIGRldmVsb3BlcnMgdGhhdCBhbiBpbXBsZW1lbnRhdGlvbiByZXF1aXJlcyBhbiBlbGVtZW50IHRvIGJlIHVzZWRcbiAqIHdpdGhpbiBhIHNwZWNpZmljIHNlbGVjdG9yLlxuICpcbiAqIEBwYXJhbSBlbCBUaGUgd2ViIGNvbXBvbmVudCBlbGVtZW50IHRoaXMgaXMgcmVxdWlyaW5nIHRoZSBlbGVtZW50LlxuICogQHBhcmFtIHRhcmdldFNlbGVjdG9ycyBUaGUgc2VsZWN0b3Igb3Igc2VsZWN0b3JzIHRoYXQgd2VyZSBub3QgZm91bmQuXG4gKi9cbmNvbnN0IHByaW50UmVxdWlyZWRFbGVtZW50RXJyb3IgPSAoZWwsIC4uLnRhcmdldFNlbGVjdG9ycykgPT4ge1xuICByZXR1cm4gY29uc29sZS5lcnJvcihgPCR7ZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpfT4gbXVzdCBiZSB1c2VkIGluc2lkZSAke3RhcmdldFNlbGVjdG9ycy5qb2luKCcgb3IgJyl9LmApO1xufTtcblxuZXhwb3J0IHsgcHJpbnRSZXF1aXJlZEVsZW1lbnRFcnJvciBhcyBhLCBwcmludElvbkVycm9yIGFzIGIsIHByaW50SW9uV2FybmluZyBhcyBwIH07XG4iLCIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgcCBhcyBwcmludElvbldhcm5pbmcgfSBmcm9tICcuL2luZGV4LWM0YjExNjc2LmpzJztcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNlbGVjdGVkIGRheSBpcyBlcXVhbCB0byB0aGUgcmVmZXJlbmNlIGRheVxuICovXG5jb25zdCBpc1NhbWVEYXkgPSAoYmFzZVBhcnRzLCBjb21wYXJlUGFydHMpID0+IHtcbiAgcmV0dXJuIChiYXNlUGFydHMubW9udGggPT09IGNvbXBhcmVQYXJ0cy5tb250aCAmJiBiYXNlUGFydHMuZGF5ID09PSBjb21wYXJlUGFydHMuZGF5ICYmIGJhc2VQYXJ0cy55ZWFyID09PSBjb21wYXJlUGFydHMueWVhcik7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaXMgdGhlIHNlbGVjdGVkIGRheSBpcyBiZWZvcmUgdGhlIHJlZmVyZW5jZSBkYXkuXG4gKi9cbmNvbnN0IGlzQmVmb3JlID0gKGJhc2VQYXJ0cywgY29tcGFyZVBhcnRzKSA9PiB7XG4gIHJldHVybiAhIShiYXNlUGFydHMueWVhciA8IGNvbXBhcmVQYXJ0cy55ZWFyIHx8XG4gICAgKGJhc2VQYXJ0cy55ZWFyID09PSBjb21wYXJlUGFydHMueWVhciAmJiBiYXNlUGFydHMubW9udGggPCBjb21wYXJlUGFydHMubW9udGgpIHx8XG4gICAgKGJhc2VQYXJ0cy55ZWFyID09PSBjb21wYXJlUGFydHMueWVhciAmJlxuICAgICAgYmFzZVBhcnRzLm1vbnRoID09PSBjb21wYXJlUGFydHMubW9udGggJiZcbiAgICAgIGJhc2VQYXJ0cy5kYXkgIT09IG51bGwgJiZcbiAgICAgIGJhc2VQYXJ0cy5kYXkgPCBjb21wYXJlUGFydHMuZGF5KSk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaXMgdGhlIHNlbGVjdGVkIGRheSBpcyBhZnRlciB0aGUgcmVmZXJlbmNlIGRheS5cbiAqL1xuY29uc3QgaXNBZnRlciA9IChiYXNlUGFydHMsIGNvbXBhcmVQYXJ0cykgPT4ge1xuICByZXR1cm4gISEoYmFzZVBhcnRzLnllYXIgPiBjb21wYXJlUGFydHMueWVhciB8fFxuICAgIChiYXNlUGFydHMueWVhciA9PT0gY29tcGFyZVBhcnRzLnllYXIgJiYgYmFzZVBhcnRzLm1vbnRoID4gY29tcGFyZVBhcnRzLm1vbnRoKSB8fFxuICAgIChiYXNlUGFydHMueWVhciA9PT0gY29tcGFyZVBhcnRzLnllYXIgJiZcbiAgICAgIGJhc2VQYXJ0cy5tb250aCA9PT0gY29tcGFyZVBhcnRzLm1vbnRoICYmXG4gICAgICBiYXNlUGFydHMuZGF5ICE9PSBudWxsICYmXG4gICAgICBiYXNlUGFydHMuZGF5ID4gY29tcGFyZVBhcnRzLmRheSkpO1xufTtcbmNvbnN0IHdhcm5JZlZhbHVlT3V0T2ZCb3VuZHMgPSAodmFsdWUsIG1pbiwgbWF4KSA9PiB7XG4gIGNvbnN0IHZhbHVlQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgZm9yIChjb25zdCB2YWwgb2YgdmFsdWVBcnJheSkge1xuICAgIGlmICgobWluICE9PSB1bmRlZmluZWQgJiYgaXNCZWZvcmUodmFsLCBtaW4pKSB8fCAobWF4ICE9PSB1bmRlZmluZWQgJiYgaXNBZnRlcih2YWwsIG1heCkpKSB7XG4gICAgICBwcmludElvbldhcm5pbmcoJ1RoZSB2YWx1ZSBwcm92aWRlZCB0byBpb24tZGF0ZXRpbWUgaXMgb3V0IG9mIGJvdW5kcy5cXG5cXG4nICtcbiAgICAgICAgYE1pbjogJHtKU09OLnN0cmluZ2lmeShtaW4pfVxcbmAgK1xuICAgICAgICBgTWF4OiAke0pTT04uc3RyaW5naWZ5KG1heCl9XFxuYCArXG4gICAgICAgIGBWYWx1ZTogJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBnaXZlbiB5ZWFyIGlzIGFcbiAqIGxlYXAgeWVhci4gUmV0dXJucyBgdHJ1ZWAgaWYgeWVhclxuICogaXMgYSBsZWFwIHllYXIuIFJldHVybnMgYGZhbHNlYFxuICogb3RoZXJ3aXNlLlxuICovXG5jb25zdCBpc0xlYXBZZWFyID0gKHllYXIpID0+IHtcbiAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xufTtcbmNvbnN0IGlzMjRIb3VyID0gKGxvY2FsZSwgaG91ckN5Y2xlKSA9PiB7XG4gIC8qKlxuICAgKiBJZiBkZXZlbG9wZXIgaGFzIGV4cGxpY2l0bHkgZW5hYmxlZCBoMjMgdGltZVxuICAgKiB0aGVuIHJldHVybiBlYXJseSBhbmQgZG8gbm90IGxvb2sgYXQgdGhlIHN5c3RlbSBkZWZhdWx0LlxuICAgKi9cbiAgaWYgKGhvdXJDeWNsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGhvdXJDeWNsZSA9PT0gJ2gyMyc7XG4gIH1cbiAgLyoqXG4gICAqIElmIGhvdXJDeWNsZSB3YXMgbm90IHNwZWNpZmllZCwgY2hlY2sgdGhlIGxvY2FsZVxuICAgKiB0aGF0IGlzIHNldCBvbiB0aGUgdXNlcidzIGRldmljZS4gV2UgZmlyc3QgY2hlY2sgdGhlXG4gICAqIEludGwuRGF0ZVRpbWVGb3JtYXQgaG91ckN5Y2xlIG9wdGlvbiBhcyBkZXZlbG9wZXJzIGNhbiBlbmNvZGUgdGhpc1xuICAgKiBvcHRpb24gaW50byB0aGUgbG9jYWxlIHN0cmluZy4gRXhhbXBsZTogYGVuLVVTLXUtaGMtaDIzYFxuICAgKi9cbiAgY29uc3QgZm9ybWF0dGVkID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCB7IGhvdXI6ICdudW1lcmljJyB9KTtcbiAgY29uc3Qgb3B0aW9ucyA9IGZvcm1hdHRlZC5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgaWYgKG9wdGlvbnMuaG91ckN5Y2xlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5ob3VyQ3ljbGUgPT09ICdoMjMnO1xuICB9XG4gIC8qKlxuICAgKiBJZiBob3VyQ3ljbGUgaXMgbm90IHNwZWNpZmllZCAoZWl0aGVyIHRocm91Z2ggbGFja1xuICAgKiBvZiBicm93c2VyIHN1cHBvcnQgb3IgbG9jYWxlIGluZm9ybWF0aW9uKSB0aGVuIGZhbGxcbiAgICogYmFjayB0byB0aGlzIHNsb3dlciBob3VyQ3ljbGUgY2hlY2suXG4gICAqL1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUoJzUvMTgvMjAyMSAwMDowMCcpO1xuICBjb25zdCBwYXJ0cyA9IGZvcm1hdHRlZC5mb3JtYXRUb1BhcnRzKGRhdGUpO1xuICBjb25zdCBob3VyID0gcGFydHMuZmluZCgocCkgPT4gcC50eXBlID09PSAnaG91cicpO1xuICBpZiAoIWhvdXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0hvdXIgdmFsdWUgbm90IGZvdW5kIGZyb20gRGF0ZVRpbWVGb3JtYXQnKTtcbiAgfVxuICByZXR1cm4gaG91ci52YWx1ZSA9PT0gJzAwJztcbn07XG4vKipcbiAqIEdpdmVuIGEgZGF0ZSBvYmplY3QsIHJldHVybnMgdGhlIG51bWJlclxuICogb2YgZGF5cyBpbiB0aGF0IG1vbnRoLlxuICogTW9udGggdmFsdWUgYmVnaW4gYXQgMSwgbm90IDAuXG4gKiBpLmUuIEphbnVhcnkgPSBtb250aCAxLlxuICovXG5jb25zdCBnZXROdW1EYXlzSW5Nb250aCA9IChtb250aCwgeWVhcikgPT4ge1xuICByZXR1cm4gbW9udGggPT09IDQgfHwgbW9udGggPT09IDYgfHwgbW9udGggPT09IDkgfHwgbW9udGggPT09IDExXG4gICAgPyAzMFxuICAgIDogbW9udGggPT09IDJcbiAgICAgID8gaXNMZWFwWWVhcih5ZWFyKVxuICAgICAgICA/IDI5XG4gICAgICAgIDogMjhcbiAgICAgIDogMzE7XG59O1xuLyoqXG4gKiBDZXJ0YWluIGxvY2FsZXMgZGlzcGxheSBtb250aCB0aGVuIHllYXIgd2hpbGVcbiAqIG90aGVycyBkaXNwbGF5IHllYXIgdGhlbiBtb250aC5cbiAqIFdlIGNhbiB1c2UgSW50bC5EYXRlVGltZUZvcm1hdCB0byBkZXRlcm1pbmVcbiAqIHRoZSBvcmRlcmluZyBmb3IgZWFjaCBsb2NhbGUuXG4gKiBUaGUgZm9ybWF0T3B0aW9ucyBwYXJhbSBjYW4gYmUgdXNlZCB0byBjdXN0b21pemVcbiAqIHdoaWNoIHBpZWNlcyBvZiBhIGRhdGUgdG8gY29tcGFyZSBhZ2FpbnN0IHRoZSBtb250aFxuICogd2l0aC4gRm9yIGV4YW1wbGUsIHNvbWUgbG9jYWxlcyByZW5kZXIgZGQvbW0veXl5eVxuICogd2hpbGUgb3RoZXJzIHJlbmRlciBtbS9kZC95eXl5LiBUaGlzIGZ1bmN0aW9uIGNhbiBiZVxuICogdXNlZCBmb3IgdmFyaWF0aW9ucyBvZiB0aGUgc2FtZSBcIm1vbnRoIGZpcnN0XCIgY2hlY2suXG4gKi9cbmNvbnN0IGlzTW9udGhGaXJzdExvY2FsZSA9IChsb2NhbGUsIGZvcm1hdE9wdGlvbnMgPSB7XG4gIG1vbnRoOiAnbnVtZXJpYycsXG4gIHllYXI6ICdudW1lcmljJyxcbn0pID0+IHtcbiAgLyoqXG4gICAqIEJ5IHNldHRpbmcgbW9udGggYW5kIHllYXIgd2UgZ3VhcmFudGVlIHRoYXQgb25seVxuICAgKiBtb250aCwgeWVhciwgYW5kIGxpdGVyYWwgKHNsYXNoZXMgJy8nLCBmb3IgZXhhbXBsZSlcbiAgICogdmFsdWVzIGFyZSBpbmNsdWRlZCBpbiB0aGUgZm9ybWF0VG9QYXJ0cyByZXN1bHRzLlxuICAgKlxuICAgKiBUaGUgb3JkZXJpbmcgb2YgdGhlIHBhcnRzIHdpbGwgYmUgZGV0ZXJtaW5lZCBieVxuICAgKiB0aGUgbG9jYWxlLiBTbyBpZiB0aGUgbW9udGggaXMgdGhlIGZpcnN0IHZhbHVlLFxuICAgKiB0aGVuIHdlIGtub3cgbW9udGggc2hvdWxkIGJlIHNob3duIGZpcnN0LiBJZiB0aGVcbiAgICogeWVhciBpcyB0aGUgZmlyc3QgdmFsdWUsIHRoZW4gd2Uga25vdyB5ZWFyIHNob3VsZCBiZSBzaG93biBmaXJzdC5cbiAgICpcbiAgICogVGhpcyBvcmRlcmluZyBjYW4gYmUgY29udHJvbGxlZCBieSBjdXN0b21pemluZyB0aGUgbG9jYWxlIHByb3BlcnR5LlxuICAgKi9cbiAgY29uc3QgcGFydHMgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIGZvcm1hdE9wdGlvbnMpLmZvcm1hdFRvUGFydHMobmV3IERhdGUoKSk7XG4gIHJldHVybiBwYXJ0c1swXS50eXBlID09PSAnbW9udGgnO1xufTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gbG9jYWxlIGZvcm1hdHMgdGhlIGRheSBwZXJpb2QgKGFtL3BtKSB0byB0aGVcbiAqIGxlZnQgb3IgcmlnaHQgb2YgdGhlIGhvdXIuXG4gKiBAcGFyYW0gbG9jYWxlIFRoZSBsb2NhbGUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGxvY2FsZSBmb3JtYXRzIHRoZSBkYXkgcGVyaW9kIHRvIHRoZSBsZWZ0IG9mIHRoZSBob3VyLlxuICovXG5jb25zdCBpc0xvY2FsZURheVBlcmlvZFJUTCA9IChsb2NhbGUpID0+IHtcbiAgY29uc3QgcGFydHMgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIHsgaG91cjogJ251bWVyaWMnIH0pLmZvcm1hdFRvUGFydHMobmV3IERhdGUoKSk7XG4gIHJldHVybiBwYXJ0c1swXS50eXBlID09PSAnZGF5UGVyaW9kJztcbn07XG5cbmNvbnN0IHR3b0RpZ2l0ID0gKHZhbCkgPT4ge1xuICByZXR1cm4gKCcwJyArICh2YWwgIT09IHVuZGVmaW5lZCA/IE1hdGguYWJzKHZhbCkgOiAnMCcpKS5zbGljZSgtMik7XG59O1xuY29uc3QgZm91ckRpZ2l0ID0gKHZhbCkgPT4ge1xuICByZXR1cm4gKCcwMDAnICsgKHZhbCAhPT0gdW5kZWZpbmVkID8gTWF0aC5hYnModmFsKSA6ICcwJykpLnNsaWNlKC00KTtcbn07XG5mdW5jdGlvbiBjb252ZXJ0RGF0YVRvSVNPKGRhdGEpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YS5tYXAoKHBhcnRzKSA9PiBjb252ZXJ0RGF0YVRvSVNPKHBhcnRzKSk7XG4gIH1cbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL05PVEUtZGF0ZXRpbWVcbiAgbGV0IHJ0biA9ICcnO1xuICBpZiAoZGF0YS55ZWFyICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBZWVlZXG4gICAgcnRuID0gZm91ckRpZ2l0KGRhdGEueWVhcik7XG4gICAgaWYgKGRhdGEubW9udGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gWVlZWS1NTVxuICAgICAgcnRuICs9ICctJyArIHR3b0RpZ2l0KGRhdGEubW9udGgpO1xuICAgICAgaWYgKGRhdGEuZGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gWVlZWS1NTS1ERFxuICAgICAgICBydG4gKz0gJy0nICsgdHdvRGlnaXQoZGF0YS5kYXkpO1xuICAgICAgICBpZiAoZGF0YS5ob3VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBZWVlZLU1NLUREVEhIOm1tOlNTXG4gICAgICAgICAgcnRuICs9IGBUJHt0d29EaWdpdChkYXRhLmhvdXIpfToke3R3b0RpZ2l0KGRhdGEubWludXRlKX06MDBgO1xuICAgICAgICAgIGlmIChkYXRhLnR6T2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFlZWVktTU0tRERUSEg6bW06U1NaXG4gICAgICAgICAgICBydG4gKz0gJ1onO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFlZWVktTU0tRERUSEg6bW06U1MrLy1ISDptbVxuICAgICAgICAgICAgcnRuICs9XG4gICAgICAgICAgICAgIChkYXRhLnR6T2Zmc2V0ID4gMCA/ICcrJyA6ICctJykgK1xuICAgICAgICAgICAgICAgIHR3b0RpZ2l0KE1hdGguZmxvb3IoTWF0aC5hYnMoZGF0YS50ek9mZnNldCAvIDYwKSkpICtcbiAgICAgICAgICAgICAgICAnOicgK1xuICAgICAgICAgICAgICAgIHR3b0RpZ2l0KGRhdGEudHpPZmZzZXQgJSA2MCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGRhdGEuaG91ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gSEg6bW1cbiAgICBydG4gPSB0d29EaWdpdChkYXRhLmhvdXIpICsgJzonICsgdHdvRGlnaXQoZGF0YS5taW51dGUpO1xuICB9XG4gIHJldHVybiBydG47XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIDEyIGhvdXIgdmFsdWUgdG8gMjQgaG91cnMuXG4gKi9cbmNvbnN0IGNvbnZlcnQxMkhvdXJUbzI0SG91ciA9IChob3VyLCBhbXBtKSA9PiB7XG4gIGlmIChhbXBtID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaG91cjtcbiAgfVxuICAvKipcbiAgICogSWYgQU0gYW5kIDEyYW1cbiAgICogdGhlbiByZXR1cm4gMDA6MDAuXG4gICAqIE90aGVyd2lzZSBqdXN0IHJldHVyblxuICAgKiB0aGUgaG91ciBzaW5jZSBpdCBpc1xuICAgKiBhbHJlYWR5IGluIDI0IGhvdXIgZm9ybWF0LlxuICAgKi9cbiAgaWYgKGFtcG0gPT09ICdhbScpIHtcbiAgICBpZiAoaG91ciA9PT0gMTIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gaG91cjtcbiAgfVxuICAvKipcbiAgICogSWYgUE0gYW5kIDEycG1cbiAgICoganVzdCByZXR1cm4gMTI6MDBcbiAgICogc2luY2UgaXQgaXMgYWxyZWFkeVxuICAgKiBpbiAyNCBob3VyIGZvcm1hdC5cbiAgICogT3RoZXJ3aXNlIGFkZCAxMiBob3Vyc1xuICAgKiB0byB0aGUgdGltZS5cbiAgICovXG4gIGlmIChob3VyID09PSAxMikge1xuICAgIHJldHVybiAxMjtcbiAgfVxuICByZXR1cm4gaG91ciArIDEyO1xufTtcbmNvbnN0IGdldFN0YXJ0T2ZXZWVrID0gKHJlZlBhcnRzKSA9PiB7XG4gIGNvbnN0IHsgZGF5T2ZXZWVrIH0gPSByZWZQYXJ0cztcbiAgaWYgKGRheU9mV2VlayA9PT0gbnVsbCB8fCBkYXlPZldlZWsgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF5IG9mIHdlZWsgcHJvdmlkZWQnKTtcbiAgfVxuICByZXR1cm4gc3VidHJhY3REYXlzKHJlZlBhcnRzLCBkYXlPZldlZWspO1xufTtcbmNvbnN0IGdldEVuZE9mV2VlayA9IChyZWZQYXJ0cykgPT4ge1xuICBjb25zdCB7IGRheU9mV2VlayB9ID0gcmVmUGFydHM7XG4gIGlmIChkYXlPZldlZWsgPT09IG51bGwgfHwgZGF5T2ZXZWVrID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRheSBvZiB3ZWVrIHByb3ZpZGVkJyk7XG4gIH1cbiAgcmV0dXJuIGFkZERheXMocmVmUGFydHMsIDYgLSBkYXlPZldlZWspO1xufTtcbmNvbnN0IGdldE5leHREYXkgPSAocmVmUGFydHMpID0+IHtcbiAgcmV0dXJuIGFkZERheXMocmVmUGFydHMsIDEpO1xufTtcbmNvbnN0IGdldFByZXZpb3VzRGF5ID0gKHJlZlBhcnRzKSA9PiB7XG4gIHJldHVybiBzdWJ0cmFjdERheXMocmVmUGFydHMsIDEpO1xufTtcbmNvbnN0IGdldFByZXZpb3VzV2VlayA9IChyZWZQYXJ0cykgPT4ge1xuICByZXR1cm4gc3VidHJhY3REYXlzKHJlZlBhcnRzLCA3KTtcbn07XG5jb25zdCBnZXROZXh0V2VlayA9IChyZWZQYXJ0cykgPT4ge1xuICByZXR1cm4gYWRkRGF5cyhyZWZQYXJ0cywgNyk7XG59O1xuLyoqXG4gKiBHaXZlbiBkYXRldGltZSBwYXJ0cywgc3VidHJhY3RcbiAqIG51bURheXMgZnJvbSB0aGUgZGF0ZS5cbiAqIFJldHVybnMgYSBuZXcgRGF0ZXRpbWVQYXJ0cyBvYmplY3RcbiAqIEN1cnJlbnRseSBjYW4gb25seSBnbyBiYWNrd2FyZCBhdCBtb3N0IDEgbW9udGguXG4gKi9cbmNvbnN0IHN1YnRyYWN0RGF5cyA9IChyZWZQYXJ0cywgbnVtRGF5cykgPT4ge1xuICBjb25zdCB7IG1vbnRoLCBkYXksIHllYXIgfSA9IHJlZlBhcnRzO1xuICBpZiAoZGF5ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBkYXkgcHJvdmlkZWQnKTtcbiAgfVxuICBjb25zdCB3b3JraW5nUGFydHMgPSB7XG4gICAgbW9udGgsXG4gICAgZGF5LFxuICAgIHllYXIsXG4gIH07XG4gIHdvcmtpbmdQYXJ0cy5kYXkgPSBkYXkgLSBudW1EYXlzO1xuICAvKipcbiAgICogSWYgd3JhcHBpbmcgdG8gcHJldmlvdXMgbW9udGhcbiAgICogdXBkYXRlIGRheXMgYW5kIGRlY3JlbWVudCBtb250aFxuICAgKi9cbiAgaWYgKHdvcmtpbmdQYXJ0cy5kYXkgPCAxKSB7XG4gICAgd29ya2luZ1BhcnRzLm1vbnRoIC09IDE7XG4gIH1cbiAgLyoqXG4gICAqIElmIG1vdmluZyB0byBwcmV2aW91cyB5ZWFyLCByZXNldFxuICAgKiBtb250aCB0byBEZWNlbWJlciBhbmQgZGVjcmVtZW50IHllYXJcbiAgICovXG4gIGlmICh3b3JraW5nUGFydHMubW9udGggPCAxKSB7XG4gICAgd29ya2luZ1BhcnRzLm1vbnRoID0gMTI7XG4gICAgd29ya2luZ1BhcnRzLnllYXIgLT0gMTtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lIGhvdyBtYW55IGRheXMgYXJlIGluIHRoZSBjdXJyZW50XG4gICAqIG1vbnRoXG4gICAqL1xuICBpZiAod29ya2luZ1BhcnRzLmRheSA8IDEpIHtcbiAgICBjb25zdCBkYXlzSW5Nb250aCA9IGdldE51bURheXNJbk1vbnRoKHdvcmtpbmdQYXJ0cy5tb250aCwgd29ya2luZ1BhcnRzLnllYXIpO1xuICAgIC8qKlxuICAgICAqIFRha2UgbnVtIGRheXMgaW4gbW9udGggYW5kIGFkZCB0aGVcbiAgICAgKiBudW1iZXIgb2YgdW5kZXJmbG93IGRheXMuIFRoaXMgbnVtYmVyIHdpbGxcbiAgICAgKiBiZSBuZWdhdGl2ZS5cbiAgICAgKiBFeGFtcGxlOiAxIHdlZWsgYmVmb3JlIEphbiAyLCAyMDIxIGlzXG4gICAgICogRGVjZW1iZXIgMjYsIDIwMjEgc286XG4gICAgICogMiAtIDcgPSAtNVxuICAgICAqIDMxICsgKC01KSA9IDI2XG4gICAgICovXG4gICAgd29ya2luZ1BhcnRzLmRheSA9IGRheXNJbk1vbnRoICsgd29ya2luZ1BhcnRzLmRheTtcbiAgfVxuICByZXR1cm4gd29ya2luZ1BhcnRzO1xufTtcbi8qKlxuICogR2l2ZW4gZGF0ZXRpbWUgcGFydHMsIGFkZFxuICogbnVtRGF5cyB0byB0aGUgZGF0ZS5cbiAqIFJldHVybnMgYSBuZXcgRGF0ZXRpbWVQYXJ0cyBvYmplY3RcbiAqIEN1cnJlbnRseSBjYW4gb25seSBnbyBmb3J3YXJkIGF0IG1vc3QgMSBtb250aC5cbiAqL1xuY29uc3QgYWRkRGF5cyA9IChyZWZQYXJ0cywgbnVtRGF5cykgPT4ge1xuICBjb25zdCB7IG1vbnRoLCBkYXksIHllYXIgfSA9IHJlZlBhcnRzO1xuICBpZiAoZGF5ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBkYXkgcHJvdmlkZWQnKTtcbiAgfVxuICBjb25zdCB3b3JraW5nUGFydHMgPSB7XG4gICAgbW9udGgsXG4gICAgZGF5LFxuICAgIHllYXIsXG4gIH07XG4gIGNvbnN0IGRheXNJbk1vbnRoID0gZ2V0TnVtRGF5c0luTW9udGgobW9udGgsIHllYXIpO1xuICB3b3JraW5nUGFydHMuZGF5ID0gZGF5ICsgbnVtRGF5cztcbiAgLyoqXG4gICAqIElmIHdyYXBwaW5nIHRvIG5leHQgbW9udGhcbiAgICogdXBkYXRlIGRheXMgYW5kIGluY3JlbWVudCBtb250aFxuICAgKi9cbiAgaWYgKHdvcmtpbmdQYXJ0cy5kYXkgPiBkYXlzSW5Nb250aCkge1xuICAgIHdvcmtpbmdQYXJ0cy5kYXkgLT0gZGF5c0luTW9udGg7XG4gICAgd29ya2luZ1BhcnRzLm1vbnRoICs9IDE7XG4gIH1cbiAgLyoqXG4gICAqIElmIG1vdmluZyB0byBuZXh0IHllYXIsIHJlc2V0XG4gICAqIG1vbnRoIHRvIEphbnVhcnkgYW5kIGluY3JlbWVudCB5ZWFyXG4gICAqL1xuICBpZiAod29ya2luZ1BhcnRzLm1vbnRoID4gMTIpIHtcbiAgICB3b3JraW5nUGFydHMubW9udGggPSAxO1xuICAgIHdvcmtpbmdQYXJ0cy55ZWFyICs9IDE7XG4gIH1cbiAgcmV0dXJuIHdvcmtpbmdQYXJ0cztcbn07XG4vKipcbiAqIEdpdmVuIERhdGV0aW1lUGFydHMsIGdlbmVyYXRlIHRoZSBwcmV2aW91cyBtb250aC5cbiAqL1xuY29uc3QgZ2V0UHJldmlvdXNNb250aCA9IChyZWZQYXJ0cykgPT4ge1xuICAvKipcbiAgICogSWYgY3VycmVudCBtb250aCBpcyBKYW51YXJ5LCB3cmFwIGJhY2t3YXJkc1xuICAgKiAgdG8gRGVjZW1iZXIgb2YgdGhlIHByZXZpb3VzIHllYXIuXG4gICAqL1xuICBjb25zdCBtb250aCA9IHJlZlBhcnRzLm1vbnRoID09PSAxID8gMTIgOiByZWZQYXJ0cy5tb250aCAtIDE7XG4gIGNvbnN0IHllYXIgPSByZWZQYXJ0cy5tb250aCA9PT0gMSA/IHJlZlBhcnRzLnllYXIgLSAxIDogcmVmUGFydHMueWVhcjtcbiAgY29uc3QgbnVtRGF5c0luTW9udGggPSBnZXROdW1EYXlzSW5Nb250aChtb250aCwgeWVhcik7XG4gIGNvbnN0IGRheSA9IG51bURheXNJbk1vbnRoIDwgcmVmUGFydHMuZGF5ID8gbnVtRGF5c0luTW9udGggOiByZWZQYXJ0cy5kYXk7XG4gIHJldHVybiB7IG1vbnRoLCB5ZWFyLCBkYXkgfTtcbn07XG4vKipcbiAqIEdpdmVuIERhdGV0aW1lUGFydHMsIGdlbmVyYXRlIHRoZSBuZXh0IG1vbnRoLlxuICovXG5jb25zdCBnZXROZXh0TW9udGggPSAocmVmUGFydHMpID0+IHtcbiAgLyoqXG4gICAqIElmIGN1cnJlbnQgbW9udGggaXMgRGVjZW1iZXIsIHdyYXAgZm9yd2FyZHNcbiAgICogIHRvIEphbnVhcnkgb2YgdGhlIG5leHQgeWVhci5cbiAgICovXG4gIGNvbnN0IG1vbnRoID0gcmVmUGFydHMubW9udGggPT09IDEyID8gMSA6IHJlZlBhcnRzLm1vbnRoICsgMTtcbiAgY29uc3QgeWVhciA9IHJlZlBhcnRzLm1vbnRoID09PSAxMiA/IHJlZlBhcnRzLnllYXIgKyAxIDogcmVmUGFydHMueWVhcjtcbiAgY29uc3QgbnVtRGF5c0luTW9udGggPSBnZXROdW1EYXlzSW5Nb250aChtb250aCwgeWVhcik7XG4gIGNvbnN0IGRheSA9IG51bURheXNJbk1vbnRoIDwgcmVmUGFydHMuZGF5ID8gbnVtRGF5c0luTW9udGggOiByZWZQYXJ0cy5kYXk7XG4gIHJldHVybiB7IG1vbnRoLCB5ZWFyLCBkYXkgfTtcbn07XG5jb25zdCBjaGFuZ2VZZWFyID0gKHJlZlBhcnRzLCB5ZWFyRGVsdGEpID0+IHtcbiAgY29uc3QgbW9udGggPSByZWZQYXJ0cy5tb250aDtcbiAgY29uc3QgeWVhciA9IHJlZlBhcnRzLnllYXIgKyB5ZWFyRGVsdGE7XG4gIGNvbnN0IG51bURheXNJbk1vbnRoID0gZ2V0TnVtRGF5c0luTW9udGgobW9udGgsIHllYXIpO1xuICBjb25zdCBkYXkgPSBudW1EYXlzSW5Nb250aCA8IHJlZlBhcnRzLmRheSA/IG51bURheXNJbk1vbnRoIDogcmVmUGFydHMuZGF5O1xuICByZXR1cm4geyBtb250aCwgeWVhciwgZGF5IH07XG59O1xuLyoqXG4gKiBHaXZlbiBEYXRldGltZVBhcnRzLCBnZW5lcmF0ZSB0aGUgcHJldmlvdXMgeWVhci5cbiAqL1xuY29uc3QgZ2V0UHJldmlvdXNZZWFyID0gKHJlZlBhcnRzKSA9PiB7XG4gIHJldHVybiBjaGFuZ2VZZWFyKHJlZlBhcnRzLCAtMSk7XG59O1xuLyoqXG4gKiBHaXZlbiBEYXRldGltZVBhcnRzLCBnZW5lcmF0ZSB0aGUgbmV4dCB5ZWFyLlxuICovXG5jb25zdCBnZXROZXh0WWVhciA9IChyZWZQYXJ0cykgPT4ge1xuICByZXR1cm4gY2hhbmdlWWVhcihyZWZQYXJ0cywgMSk7XG59O1xuLyoqXG4gKiBJZiBQTSwgdGhlbiBpbnRlcm5hbCB2YWx1ZSBzaG91bGRcbiAqIGJlIGNvbnZlcnRlZCB0byAyNC1ociB0aW1lLlxuICogRG9lcyBub3QgYXBwbHkgd2hlbiBwdWJsaWNcbiAqIHZhbHVlcyBhcmUgYWxyZWFkeSAyNC1ociB0aW1lLlxuICovXG5jb25zdCBnZXRJbnRlcm5hbEhvdXJWYWx1ZSA9IChob3VyLCB1c2UyNEhvdXIsIGFtcG0pID0+IHtcbiAgaWYgKHVzZTI0SG91cikge1xuICAgIHJldHVybiBob3VyO1xuICB9XG4gIHJldHVybiBjb252ZXJ0MTJIb3VyVG8yNEhvdXIoaG91ciwgYW1wbSk7XG59O1xuLyoqXG4gKiBVbmxlc3Mgb3RoZXJ3aXNlIHN0YXRlZCwgYWxsIG1vbnRoIHZhbHVlcyBhcmVcbiAqIDEgaW5kZXhlZCBpbnN0ZWFkIG9mIHRoZSB0eXBpY2FsIDAgaW5kZXggaW4gSlMgRGF0ZS5cbiAqIEV4YW1wbGU6XG4gKiAgIEphbnVhcnkgPSBNb250aCAwIHdoZW4gdXNpbmcgSlMgRGF0ZVxuICogICBKYW51YXJ5ID0gTW9udGggMSB3aGVuIHVzaW5nIHRoaXMgZGF0ZXRpbWUgdXRpbFxuICovXG4vKipcbiAqIEdpdmVuIHRoZSBjdXJyZW50IGRhdGV0aW1lIHBhcnRzIGFuZCBhIG5ldyBBTS9QTSB2YWx1ZVxuICogY2FsY3VsYXRlIHdoYXQgdGhlIGhvdXIgc2hvdWxkIGJlIGluIDI0LWhvdXIgdGltZSBmb3JtYXQuXG4gKiBVc2VkIHdoZW4gdG9nZ2xpbmcgdGhlIEFNL1BNIHNlZ21lbnQgc2luY2Ugd2Ugc3RvcmUgb3VyIGhvdXJzXG4gKiBpbiAyNC1ob3VyIHRpbWUgZm9ybWF0IGludGVybmFsbHkuXG4gKi9cbmNvbnN0IGNhbGN1bGF0ZUhvdXJGcm9tQU1QTSA9IChjdXJyZW50UGFydHMsIG5ld0FNUE0pID0+IHtcbiAgY29uc3QgeyBhbXBtOiBjdXJyZW50QU1QTSwgaG91ciB9ID0gY3VycmVudFBhcnRzO1xuICBsZXQgbmV3SG91ciA9IGhvdXI7XG4gIC8qKlxuICAgKiBJZiBnb2luZyBmcm9tIEFNIC0tPiBQTSwgbmVlZCB0byB1cGRhdGUgdGhlXG4gICAqXG4gICAqL1xuICBpZiAoY3VycmVudEFNUE0gPT09ICdhbScgJiYgbmV3QU1QTSA9PT0gJ3BtJykge1xuICAgIG5ld0hvdXIgPSBjb252ZXJ0MTJIb3VyVG8yNEhvdXIobmV3SG91ciwgJ3BtJyk7XG4gICAgLyoqXG4gICAgICogSWYgZ29pbmcgZnJvbSBQTSAtLT4gQU1cbiAgICAgKi9cbiAgfVxuICBlbHNlIGlmIChjdXJyZW50QU1QTSA9PT0gJ3BtJyAmJiBuZXdBTVBNID09PSAnYW0nKSB7XG4gICAgbmV3SG91ciA9IE1hdGguYWJzKG5ld0hvdXIgLSAxMik7XG4gIH1cbiAgcmV0dXJuIG5ld0hvdXI7XG59O1xuLyoqXG4gKiBVcGRhdGVzIHBhcnRzIHRvIGVuc3VyZSB0aGF0IG1vbnRoIGFuZCBkYXlcbiAqIHZhbHVlcyBhcmUgdmFsaWQuIEZvciBkYXlzIHRoYXQgZG8gbm90IGV4aXN0LFxuICogdGhlIGNsb3Nlc3QgdmFsaWQgZGF5IGlzIHVzZWQuXG4gKi9cbmNvbnN0IHZhbGlkYXRlUGFydHMgPSAocGFydHMpID0+IHtcbiAgY29uc3QgeyBtb250aCwgZGF5LCB5ZWFyIH0gPSBwYXJ0cztcbiAgY29uc3QgcGFydHNDb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgcGFydHMpO1xuICBjb25zdCBudW1EYXlzID0gZ2V0TnVtRGF5c0luTW9udGgobW9udGgsIHllYXIpO1xuICAvKipcbiAgICogSWYgdGhlIG1heCBudW1iZXIgb2YgZGF5c1xuICAgKiBpcyBncmVhdGVyIHRoYW4gdGhlIGRheSB3ZSB3YW50XG4gICAqIHRvIHNldCwgdXBkYXRlIHRoZSBEYXRldGltZVBhcnRzXG4gICAqIGRheSBmaWVsZCB0byBiZSB0aGUgbWF4IGRheXMuXG4gICAqL1xuICBpZiAoZGF5ICE9PSBudWxsICYmIG51bURheXMgPCBkYXkpIHtcbiAgICBwYXJ0c0NvcHkuZGF5ID0gbnVtRGF5cztcbiAgfVxuICByZXR1cm4gcGFydHNDb3B5O1xufTtcblxuY29uc3QgZ2V0Rm9ybWF0dGVkRGF5UGVyaW9kID0gKGRheVBlcmlvZCkgPT4ge1xuICBpZiAoZGF5UGVyaW9kID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIGRheVBlcmlvZC50b1VwcGVyQ2FzZSgpO1xufTtcbmNvbnN0IGdldExvY2FsaXplZFRpbWUgPSAobG9jYWxlLCByZWZQYXJ0cywgdXNlMjRIb3VyKSA9PiB7XG4gIGlmIChyZWZQYXJ0cy5ob3VyID09PSB1bmRlZmluZWQgfHwgcmVmUGFydHMubWludXRlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJ0ludmFsaWQgVGltZSc7XG4gIH1cbiAgcmV0dXJuIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwge1xuICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICBtaW51dGU6ICdudW1lcmljJyxcbiAgICB0aW1lWm9uZTogJ1VUQycsXG4gICAgLyoqXG4gICAgICogV2UgdXNlIGhvdXJDeWNsZSBoZXJlIGluc3RlYWQgb2YgaG91cjEyIGR1ZSB0bzpcbiAgICAgKiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMzQ3MzE2JnE9aG91cjEyJmNhbj0yXG4gICAgICovXG4gICAgaG91ckN5Y2xlOiB1c2UyNEhvdXIgPyAnaDIzJyA6ICdoMTInLFxuICB9KS5mb3JtYXQobmV3IERhdGUoY29udmVydERhdGFUb0lTTyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlZlBhcnRzKSwgeyBcbiAgICAvLyBUT0RPOiBGVy0xODMxIHdpbGwgcmVtb3ZlIHRoZSBuZWVkIHRvIG1hbnVhbGx5IHNldCB0aGUgdHpPZmZzZXQgdG8gdW5kZWZpbmVkXG4gICAgdHpPZmZzZXQ6IHVuZGVmaW5lZCB9KSkpKTtcbn07XG4vKipcbiAqIEFkZHMgcGFkZGluZyB0byBhIHRpbWUgdmFsdWUgc29cbiAqIHRoYXQgaXQgaXMgYWx3YXlzIDIgZGlnaXRzLlxuICovXG5jb25zdCBhZGRUaW1lUGFkZGluZyA9ICh2YWx1ZSkgPT4ge1xuICBjb25zdCB2YWx1ZVRvU3RyaW5nID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgaWYgKHZhbHVlVG9TdHJpbmcubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiB2YWx1ZVRvU3RyaW5nO1xuICB9XG4gIHJldHVybiBgMCR7dmFsdWVUb1N0cmluZ31gO1xufTtcbi8qKlxuICogRm9ybWF0cyAyNCBob3VyIHRpbWVzIHNvIHRoYXRcbiAqIGl0IGFsd2F5cyBoYXMgMiBkaWdpdHMuIEZvclxuICogMTIgaG91ciB0aW1lcyBpdCBlbnN1cmVzIHRoYXRcbiAqIGhvdXIgMCBpcyBmb3JtYXR0ZWQgYXMgJzEyJy5cbiAqL1xuY29uc3QgZ2V0Rm9ybWF0dGVkSG91ciA9IChob3VyLCB1c2UyNEhvdXIpID0+IHtcbiAgaWYgKHVzZTI0SG91cikge1xuICAgIHJldHVybiBhZGRUaW1lUGFkZGluZyhob3VyKTtcbiAgfVxuICAvKipcbiAgICogSWYgdXNpbmcgMTIgaG91clxuICAgKiBmb3JtYXQsIG1ha2Ugc3VyZSBob3VyXG4gICAqIDAgaXMgZm9ybWF0dGVkIGFzICcxMicuXG4gICAqL1xuICBpZiAoaG91ciA9PT0gMCkge1xuICAgIHJldHVybiAnMTInO1xuICB9XG4gIHJldHVybiBob3VyLnRvU3RyaW5nKCk7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gYXJpYS1sYWJlbCB0byBiZSByZWFkIGJ5IHNjcmVlbiByZWFkZXJzXG4gKiBnaXZlbiBhIGxvY2FsLCBhIGRhdGUsIGFuZCB3aGV0aGVyIG9yIG5vdCB0aGF0IGRhdGUgaXNcbiAqIHRvZGF5J3MgZGF0ZS5cbiAqL1xuY29uc3QgZ2VuZXJhdGVEYXlBcmlhTGFiZWwgPSAobG9jYWxlLCB0b2RheSwgcmVmUGFydHMpID0+IHtcbiAgaWYgKHJlZlBhcnRzLmRheSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBNTS9ERC9ZWVlZIHdpbGwgcmV0dXJuIG1pZG5pZ2h0IGluIHRoZSB1c2VyJ3MgdGltZXpvbmUuXG4gICAqL1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUoYCR7cmVmUGFydHMubW9udGh9LyR7cmVmUGFydHMuZGF5fS8ke3JlZlBhcnRzLnllYXJ9IEdNVCswMDAwYCk7XG4gIGNvbnN0IGxhYmVsU3RyaW5nID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCB7XG4gICAgd2Vla2RheTogJ2xvbmcnLFxuICAgIG1vbnRoOiAnbG9uZycsXG4gICAgZGF5OiAnbnVtZXJpYycsXG4gICAgdGltZVpvbmU6ICdVVEMnLFxuICB9KS5mb3JtYXQoZGF0ZSk7XG4gIC8qKlxuICAgKiBJZiBkYXRlIGlzIHRvZGF5LCBwcmVwZW5kIFwiVG9kYXlcIiBzbyBzY3JlZW4gcmVhZGVycyBpbmRpY2F0ZVxuICAgKiB0aGF0IHRoZSBkYXRlIGlzIHRvZGF5LlxuICAgKi9cbiAgcmV0dXJuIHRvZGF5ID8gYFRvZGF5LCAke2xhYmVsU3RyaW5nfWAgOiBsYWJlbFN0cmluZztcbn07XG4vKipcbiAqIEdldHMgdGhlIGRheSBvZiB0aGUgd2VlaywgbW9udGgsIGFuZCBkYXlcbiAqIFVzZWQgZm9yIHRoZSBoZWFkZXIgaW4gTUQgbW9kZS5cbiAqL1xuY29uc3QgZ2V0TW9udGhBbmREYXkgPSAobG9jYWxlLCByZWZQYXJ0cykgPT4ge1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUoYCR7cmVmUGFydHMubW9udGh9LyR7cmVmUGFydHMuZGF5fS8ke3JlZlBhcnRzLnllYXJ9IEdNVCswMDAwYCk7XG4gIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdzaG9ydCcsIGRheTogJ251bWVyaWMnLCB0aW1lWm9uZTogJ1VUQycgfSkuZm9ybWF0KGRhdGUpO1xufTtcbi8qKlxuICogR2l2ZW4gYSBsb2NhbGUgYW5kIGEgZGF0ZSBvYmplY3QsXG4gKiByZXR1cm4gYSBmb3JtYXR0ZWQgc3RyaW5nIHRoYXQgaW5jbHVkZXNcbiAqIHRoZSBtb250aCBuYW1lIGFuZCBmdWxsIHllYXIuXG4gKiBFeGFtcGxlOiBNYXkgMjAyMVxuICovXG5jb25zdCBnZXRNb250aEFuZFllYXIgPSAobG9jYWxlLCByZWZQYXJ0cykgPT4ge1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUoYCR7cmVmUGFydHMubW9udGh9LyR7cmVmUGFydHMuZGF5fS8ke3JlZlBhcnRzLnllYXJ9IEdNVCswMDAwYCk7XG4gIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIHsgbW9udGg6ICdsb25nJywgeWVhcjogJ251bWVyaWMnLCB0aW1lWm9uZTogJ1VUQycgfSkuZm9ybWF0KGRhdGUpO1xufTtcbi8qKlxuICogR2l2ZW4gYSBsb2NhbGUgYW5kIGEgZGF0ZSBvYmplY3QsXG4gKiByZXR1cm4gYSBmb3JtYXR0ZWQgc3RyaW5nIHRoYXQgaW5jbHVkZXNcbiAqIHRoZSBzaG9ydCBtb250aCwgbnVtZXJpYyBkYXksIGFuZCBmdWxsIHllYXIuXG4gKiBFeGFtcGxlOiBBcHIgMjIsIDIwMjFcbiAqL1xuY29uc3QgZ2V0TW9udGhEYXlBbmRZZWFyID0gKGxvY2FsZSwgcmVmUGFydHMpID0+IHtcbiAgcmV0dXJuIGdldExvY2FsaXplZERhdGVUaW1lKGxvY2FsZSwgcmVmUGFydHMsIHsgbW9udGg6ICdzaG9ydCcsIGRheTogJ251bWVyaWMnLCB5ZWFyOiAnbnVtZXJpYycgfSk7XG59O1xuLyoqXG4gKiBHaXZlbiBhIGxvY2FsZSBhbmQgYSBkYXRlIG9iamVjdCxcbiAqIHJldHVybiBhIGZvcm1hdHRlZCBzdHJpbmcgdGhhdCBpbmNsdWRlc1xuICogdGhlIG51bWVyaWMgZGF5LlxuICogTm90ZTogU29tZSBsYW5ndWFnZXMgd2lsbCBhZGQgbGl0ZXJhbCBjaGFyYWN0ZXJzXG4gKiB0byB0aGUgZW5kLiBUaGlzIGZ1bmN0aW9uIHJlbW92ZXMgdGhvc2UgbGl0ZXJhbHMuXG4gKiBFeGFtcGxlOiAyOVxuICovXG5jb25zdCBnZXREYXkgPSAobG9jYWxlLCByZWZQYXJ0cykgPT4ge1xuICByZXR1cm4gZ2V0TG9jYWxpemVkRGF0ZVRpbWVQYXJ0cyhsb2NhbGUsIHJlZlBhcnRzLCB7IGRheTogJ251bWVyaWMnIH0pLmZpbmQoKG9iaikgPT4gb2JqLnR5cGUgPT09ICdkYXknKS52YWx1ZTtcbn07XG4vKipcbiAqIEdpdmVuIGEgbG9jYWxlIGFuZCBhIGRhdGUgb2JqZWN0LFxuICogcmV0dXJuIGEgZm9ybWF0dGVkIHN0cmluZyB0aGF0IGluY2x1ZGVzXG4gKiB0aGUgbnVtZXJpYyB5ZWFyLlxuICogRXhhbXBsZTogMjAyMlxuICovXG5jb25zdCBnZXRZZWFyID0gKGxvY2FsZSwgcmVmUGFydHMpID0+IHtcbiAgcmV0dXJuIGdldExvY2FsaXplZERhdGVUaW1lKGxvY2FsZSwgcmVmUGFydHMsIHsgeWVhcjogJ251bWVyaWMnIH0pO1xufTtcbmNvbnN0IGdldE5vcm1hbGl6ZWREYXRlID0gKHJlZlBhcnRzKSA9PiB7XG4gIGNvbnN0IHRpbWVTdHJpbmcgPSByZWZQYXJ0cy5ob3VyICE9PSB1bmRlZmluZWQgJiYgcmVmUGFydHMubWludXRlICE9PSB1bmRlZmluZWQgPyBgICR7cmVmUGFydHMuaG91cn06JHtyZWZQYXJ0cy5taW51dGV9YCA6ICcnO1xuICByZXR1cm4gbmV3IERhdGUoYCR7cmVmUGFydHMubW9udGh9LyR7cmVmUGFydHMuZGF5fS8ke3JlZlBhcnRzLnllYXJ9JHt0aW1lU3RyaW5nfSBHTVQrMDAwMGApO1xufTtcbi8qKlxuICogR2l2ZW4gYSBsb2NhbGUsIERhdGV0aW1lUGFydHMsIGFuZCBvcHRpb25zXG4gKiBmb3JtYXQgdGhlIERhdGV0aW1lUGFydHMgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gKiBhbmQgbG9jYWxlIGNvbWJpbmF0aW9uLiBUaGlzIHJldHVybnMgYSBzdHJpbmcuIElmXG4gKiB5b3Ugd2FudCBhbiBhcnJheSBvZiB0aGUgaW5kaXZpZHVhbCBwaWVjZXNcbiAqIHRoYXQgbWFrZSB1cCB0aGUgbG9jYWxpemVkIGRhdGUgc3RyaW5nLCB1c2VcbiAqIGdldExvY2FsaXplZERhdGVUaW1lUGFydHMuXG4gKi9cbmNvbnN0IGdldExvY2FsaXplZERhdGVUaW1lID0gKGxvY2FsZSwgcmVmUGFydHMsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgZGF0ZSA9IGdldE5vcm1hbGl6ZWREYXRlKHJlZlBhcnRzKTtcbiAgcmV0dXJuIGdldERhdGVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KGRhdGUpO1xufTtcbi8qKlxuICogR2l2ZW4gYSBsb2NhbGUsIERhdGV0aW1lUGFydHMsIGFuZCBvcHRpb25zXG4gKiBmb3JtYXQgdGhlIERhdGV0aW1lUGFydHMgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gKiBhbmQgbG9jYWxlIGNvbWJpbmF0aW9uLiBUaGlzIHJldHVybnMgYW4gYXJyYXkgb2ZcbiAqIGVhY2ggcGllY2Ugb2YgdGhlIGRhdGUuXG4gKi9cbmNvbnN0IGdldExvY2FsaXplZERhdGVUaW1lUGFydHMgPSAobG9jYWxlLCByZWZQYXJ0cywgb3B0aW9ucykgPT4ge1xuICBjb25zdCBkYXRlID0gZ2V0Tm9ybWFsaXplZERhdGUocmVmUGFydHMpO1xuICByZXR1cm4gZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXRUb1BhcnRzKGRhdGUpO1xufTtcbi8qKlxuICogV3JhcHBlciBmdW5jdGlvbiBmb3IgSW50bC5EYXRlVGltZUZvcm1hdC5cbiAqIEFsbG93cyBkZXZlbG9wZXJzIHRvIGFwcGx5IGFuIGFsbG93ZWQgZm9ybWF0IHRvIERhdGV0aW1lUGFydHMuXG4gKiBUaGlzIGZ1bmN0aW9uIGFsc28gaGFzIGJ1aWx0IGluIHNhZmVndWFyZHMgZm9yIG9sZGVyIGJyb3dzZXIgYnVnc1xuICogd2l0aCBJbnRsLkRhdGVUaW1lRm9ybWF0LlxuICovXG5jb25zdCBnZXREYXRlVGltZUZvcm1hdCA9IChsb2NhbGUsIG9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyB0aW1lWm9uZTogJ1VUQycgfSkpO1xufTtcbi8qKlxuICogR2V0cyBhIGxvY2FsaXplZCB2ZXJzaW9uIG9mIFwiVG9kYXlcIlxuICogRmFsbHMgYmFjayB0byBcIlRvZGF5XCIgaW4gRW5nbGlzaCBmb3JcbiAqIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgUmVsYXRpdmVUaW1lRm9ybWF0LlxuICovXG5jb25zdCBnZXRUb2RheUxhYmVsID0gKGxvY2FsZSkgPT4ge1xuICBpZiAoJ1JlbGF0aXZlVGltZUZvcm1hdCcgaW4gSW50bCkge1xuICAgIGNvbnN0IGxhYmVsID0gbmV3IEludGwuUmVsYXRpdmVUaW1lRm9ybWF0KGxvY2FsZSwgeyBudW1lcmljOiAnYXV0bycgfSkuZm9ybWF0KDAsICdkYXknKTtcbiAgICByZXR1cm4gbGFiZWwuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBsYWJlbC5zbGljZSgxKTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gJ1RvZGF5JztcbiAgfVxufTtcbi8qKlxuICogV2hlbiBjYWxsaW5nIHRvSVNPU3RyaW5nKCksIHRoZSBicm93c2VyXG4gKiB3aWxsIGNvbnZlcnQgdGhlIGRhdGUgdG8gVVRDIHRpbWUgYnkgZWl0aGVyIGFkZGluZ1xuICogb3Igc3VidHJhY3RpbmcgdGhlIHRpbWUgem9uZSBvZmZzZXQuXG4gKiBUbyB3b3JrIGFyb3VuZCB0aGlzLCB3ZSBuZWVkIHRvIGVpdGhlciBhZGRcbiAqIG9yIHN1YnRyYWN0IHRoZSB0aW1lIHpvbmUgb2Zmc2V0IHRvIHRoZSBEYXRlXG4gKiBvYmplY3QgcHJpb3IgdG8gY2FsbGluZyB0b0lTT1N0cmluZygpLlxuICogVGhpcyBhbGxvd3MgdXMgdG8gZ2V0IGFuIElTTyBzdHJpbmdcbiAqIHRoYXQgaXMgaW4gdGhlIHVzZXIncyB0aW1lIHpvbmUuXG4gKlxuICogRXhhbXBsZTpcbiAqIFRpbWUgem9uZSBvZmZzZXQgaXMgMjQwXG4gKiBNZWFuaW5nOiBUaGUgYnJvd3NlciBuZWVkcyB0byBhZGQgMjQwIG1pbnV0ZXNcbiAqIHRvIHRoZSBEYXRlIG9iamVjdCB0byBnZXQgVVRDIHRpbWUuXG4gKiBXaGF0IElvbmljIGRvZXM6IFdlIHN1YnRyYWN0IDI0MCBtaW51dGVzXG4gKiBmcm9tIHRoZSBEYXRlIG9iamVjdC4gVGhlIGJyb3dzZXIgdGhlbiBhZGRzXG4gKiAyNDAgbWludXRlcyBpbiB0b0lTT1N0cmluZygpLiBUaGUgcmVzdWx0XG4gKiBpcyBhIHRpbWUgdGhhdCBpcyBpbiB0aGUgdXNlcidzIHRpbWUgem9uZVxuICogYW5kIG5vdCBVVEMuXG4gKlxuICogTm90ZTogU29tZSB0aW1lem9uZXMgaW5jbHVkZSBtaW51dGUgYWRqdXN0bWVudHNcbiAqIHN1Y2ggYXMgMzAgb3IgNDUgbWludXRlcy4gVGhpcyBpcyB3aHkgd2UgdXNlIHNldE1pbnV0ZXNcbiAqIGluc3RlYWQgb2Ygc2V0SG91cnMuXG4gKiBFeGFtcGxlOiBJbmRpYSBTdGFuZGFyZCBUaW1lXG4gKiBUaW1lem9uZSBvZmZzZXQ6IC0zMzAgPSAtNS41IGhvdXJzLlxuICpcbiAqIExpc3Qgb2YgdGltZXpvbmVzIHdpdGggMzAgYW5kIDQ1IG1pbnV0ZSB0aW1lem9uZXM6XG4gKiBodHRwczovL3d3dy50aW1lYW5kZGF0ZS5jb20vdGltZS90aW1lLXpvbmVzLWludGVyZXN0aW5nLmh0bWxcbiAqL1xuY29uc3QgcmVtb3ZlRGF0ZVR6T2Zmc2V0ID0gKGRhdGUpID0+IHtcbiAgY29uc3QgdHpPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIGRhdGUuc2V0TWludXRlcyhkYXRlLmdldE1pbnV0ZXMoKSAtIHR6T2Zmc2V0KTtcbiAgcmV0dXJuIGRhdGU7XG59O1xuY29uc3QgREFURV9BTSA9IHJlbW92ZURhdGVUek9mZnNldChuZXcgRGF0ZSgnMjAyMlQwMTowMCcpKTtcbmNvbnN0IERBVEVfUE0gPSByZW1vdmVEYXRlVHpPZmZzZXQobmV3IERhdGUoJzIwMjJUMTM6MDAnKSk7XG4vKipcbiAqIEZvcm1hdHMgdGhlIGxvY2FsZSdzIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGF5IHBlcmlvZCAoYW0vcG0pIGZvciBhIGdpdmVuXG4gKiByZWYgcGFydHMgZGF5IHBlcmlvZC5cbiAqXG4gKiBAcGFyYW0gbG9jYWxlIFRoZSBsb2NhbGUgdG8gZm9ybWF0IHRoZSBkYXkgcGVyaW9kIGluLlxuICogQHBhcmFtIHZhbHVlIFRoZSBkYXRlIHN0cmluZywgaW4gSVNPIGZvcm1hdC5cbiAqIEByZXR1cm5zIFRoZSBsb2NhbGl6ZWQgZGF5IHBlcmlvZCAoYW0vcG0pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiB2YWx1ZS5cbiAqL1xuY29uc3QgZ2V0TG9jYWxpemVkRGF5UGVyaW9kID0gKGxvY2FsZSwgZGF5UGVyaW9kKSA9PiB7XG4gIGNvbnN0IGRhdGUgPSBkYXlQZXJpb2QgPT09ICdhbScgPyBEQVRFX0FNIDogREFURV9QTTtcbiAgY29uc3QgbG9jYWxpemVkRGF5UGVyaW9kID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCB7XG4gICAgaG91cjogJ251bWVyaWMnLFxuICAgIHRpbWVab25lOiAnVVRDJyxcbiAgfSlcbiAgICAuZm9ybWF0VG9QYXJ0cyhkYXRlKVxuICAgIC5maW5kKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09ICdkYXlQZXJpb2QnKTtcbiAgaWYgKGxvY2FsaXplZERheVBlcmlvZCkge1xuICAgIHJldHVybiBsb2NhbGl6ZWREYXlQZXJpb2QudmFsdWU7XG4gIH1cbiAgcmV0dXJuIGdldEZvcm1hdHRlZERheVBlcmlvZChkYXlQZXJpb2QpO1xufTtcbi8qKlxuICogRm9ybWF0cyB0aGUgZGF0ZXRpbWUncyB2YWx1ZSB0byBhIHN0cmluZywgZm9yIHVzZSBpbiB0aGUgbmF0aXZlIGlucHV0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gZm9ybWF0LCBlaXRoZXIgYW4gSVNPIHN0cmluZyBvciBhbiBhcnJheSB0aGVyZW9mLlxuICovXG5jb25zdCBmb3JtYXRWYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKCcsJykgOiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBkYXRlIGFzXG4gKiBhbiBJU08gc3RyaW5nIGluIHRoZSB1c2VyJ3NcbiAqIHRpbWUgem9uZS5cbiAqL1xuY29uc3QgZ2V0VG9kYXkgPSAoKSA9PiB7XG4gIC8qKlxuICAgKiBpb24tZGF0ZXRpbWUgaW50ZW50aW9uYWxseSBkb2VzIG5vdFxuICAgKiBwYXJzZSB0aW1lIHpvbmVzL2RvIGF1dG9tYXRpYyB0aW1lIHpvbmVcbiAgICogY29udmVyc2lvbiB3aGVuIGFjY2VwdGluZyB1c2VyIGlucHV0LlxuICAgKiBIb3dldmVyIHdoZW4gd2UgZ2V0IHRvZGF5J3MgZGF0ZSBzdHJpbmcsXG4gICAqIHdlIHdhbnQgaXQgZm9ybWF0dGVkIHJlbGF0aXZlIHRvIHRoZSB1c2VyJ3NcbiAgICogdGltZSB6b25lLlxuICAgKlxuICAgKiBXaGVuIGNhbGxpbmcgdG9JU09TdHJpbmcoKSwgdGhlIGJyb3dzZXJcbiAgICogd2lsbCBjb252ZXJ0IHRoZSBkYXRlIHRvIFVUQyB0aW1lIGJ5IGVpdGhlciBhZGRpbmdcbiAgICogb3Igc3VidHJhY3RpbmcgdGhlIHRpbWUgem9uZSBvZmZzZXQuXG4gICAqIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHdlIG5lZWQgdG8gZWl0aGVyIGFkZFxuICAgKiBvciBzdWJ0cmFjdCB0aGUgdGltZSB6b25lIG9mZnNldCB0byB0aGUgRGF0ZVxuICAgKiBvYmplY3QgcHJpb3IgdG8gY2FsbGluZyB0b0lTT1N0cmluZygpLlxuICAgKiBUaGlzIGFsbG93cyB1cyB0byBnZXQgYW4gSVNPIHN0cmluZ1xuICAgKiB0aGF0IGlzIGluIHRoZSB1c2VyJ3MgdGltZSB6b25lLlxuICAgKi9cbiAgcmV0dXJuIHJlbW92ZURhdGVUek9mZnNldChuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpO1xufTtcbmNvbnN0IG1pbnV0ZXMgPSBbXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAyMCwgMjEsIDIyLCAyMywgMjQsIDI1LCAyNiwgMjcsIDI4LCAyOSwgMzAsIDMxLFxuICAzMiwgMzMsIDM0LCAzNSwgMzYsIDM3LCAzOCwgMzksIDQwLCA0MSwgNDIsIDQzLCA0NCwgNDUsIDQ2LCA0NywgNDgsIDQ5LCA1MCwgNTEsIDUyLCA1MywgNTQsIDU1LCA1NiwgNTcsIDU4LCA1OSxcbl07XG5jb25zdCBob3VyMTIgPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExXTtcbmNvbnN0IGhvdXIyMyA9IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjAsIDIxLCAyMiwgMjNdO1xuLyoqXG4gKiBHaXZlbiBhIGxvY2FsZSBhbmQgYSBtb2RlLFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggZm9ybWF0dGVkIGRheXNcbiAqIG9mIHRoZSB3ZWVrLiBpT1Mgc2hvdWxkIGRpc3BsYXkgZGF5c1xuICogc3VjaCBhcyBcIk1vblwiIG9yIFwiVHVlXCIuXG4gKiBNRCBzaG91bGQgZGlzcGxheSBkYXlzIHN1Y2ggYXMgXCJNXCJcbiAqIG9yIFwiVFwiLlxuICovXG5jb25zdCBnZXREYXlzT2ZXZWVrID0gKGxvY2FsZSwgbW9kZSwgZmlyc3REYXlPZldlZWsgPSAwKSA9PiB7XG4gIC8qKlxuICAgKiBOb3YgMXN0LCAyMDIwIHN0YXJ0cyBvbiBhIFN1bmRheS5cbiAgICogaW9uLWRhdGV0aW1lIGFzc3VtZXMgd2Vla3Mgc3RhcnQgb24gU3VuZGF5LFxuICAgKiBidXQgaXMgY29uZmlndXJhYmxlIHZpYSBgZmlyc3REYXlPZldlZWtgLlxuICAgKi9cbiAgY29uc3Qgd2Vla2RheUZvcm1hdCA9IG1vZGUgPT09ICdpb3MnID8gJ3Nob3J0JyA6ICduYXJyb3cnO1xuICBjb25zdCBpbnRsID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCB7IHdlZWtkYXk6IHdlZWtkYXlGb3JtYXQgfSk7XG4gIGNvbnN0IHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKCcxMS8wMS8yMDIwJyk7XG4gIGNvbnN0IGRheXNPZldlZWsgPSBbXTtcbiAgLyoqXG4gICAqIEZvciBlYWNoIGRheSBvZiB0aGUgd2VlayxcbiAgICogZ2V0IHRoZSBkYXkgbmFtZS5cbiAgICovXG4gIGZvciAobGV0IGkgPSBmaXJzdERheU9mV2VlazsgaSA8IGZpcnN0RGF5T2ZXZWVrICsgNzsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudERhdGUgPSBuZXcgRGF0ZShzdGFydERhdGUpO1xuICAgIGN1cnJlbnREYXRlLnNldERhdGUoY3VycmVudERhdGUuZ2V0RGF0ZSgpICsgaSk7XG4gICAgZGF5c09mV2Vlay5wdXNoKGludGwuZm9ybWF0KGN1cnJlbnREYXRlKSk7XG4gIH1cbiAgcmV0dXJuIGRheXNPZldlZWs7XG59O1xuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIG9mIHRoZVxuICogZGF5cyBpbiBhIG1vbnRoIGZvciBhIGdpdmVuIHllYXIuIFZhbHVlcyBhcmVcbiAqIGFsaWduZWQgd2l0aCBhIHdlZWsgY2FsZW5kYXIgc3RhcnRpbmcgb25cbiAqIHRoZSBmaXJzdERheU9mV2VlayB2YWx1ZSAoU3VuZGF5IGJ5IGRlZmF1bHQpXG4gKiB1c2luZyBudWxsIHZhbHVlcy5cbiAqL1xuY29uc3QgZ2V0RGF5c09mTW9udGggPSAobW9udGgsIHllYXIsIGZpcnN0RGF5T2ZXZWVrKSA9PiB7XG4gIGNvbnN0IG51bURheXMgPSBnZXROdW1EYXlzSW5Nb250aChtb250aCwgeWVhcik7XG4gIGNvbnN0IGZpcnN0T2ZNb250aCA9IG5ldyBEYXRlKGAke21vbnRofS8xLyR7eWVhcn1gKS5nZXREYXkoKTtcbiAgLyoqXG4gICAqIFRvIGdldCB0aGUgZmlyc3QgZGF5IG9mIHRoZSBtb250aCBhbGlnbmVkIG9uIHRoZSBjb3JyZWN0XG4gICAqIGRheSBvZiB0aGUgd2Vlaywgd2UgbmVlZCB0byBkZXRlcm1pbmUgaG93IG1hbnkgXCJmaWxsZXJcIiBkYXlzXG4gICAqIHRvIGdlbmVyYXRlLiBUaGVzZSBmaWxsZXIgZGF5cyBhcyBlbXB0eS9kaXNhYmxlZCBidXR0b25zXG4gICAqIHRoYXQgZmlsbCB0aGUgc3BhY2Ugb2YgdGhlIGRheXMgb2YgdGhlIHdlZWsgYmVmb3JlIHRoZSBmaXJzdFxuICAgKiBvZiB0aGUgbW9udGguXG4gICAqXG4gICAqIFRoZXJlIGFyZSB0d28gY2FzZXMgaGVyZTpcbiAgICpcbiAgICogMS4gSWYgZmlyc3RPZk1vbnRoID0gNCwgZmlyc3REYXlPZldlZWsgPSAwIHRoZW4gdGhlIG9mZnNldFxuICAgKiBpcyAoNCAtICgwICsgMSkpID0gMy4gU2luY2UgdGhlIG9mZnNldCBsb29wIGdvZXMgZnJvbSAwIHRvIDMgaW5jbHVzaXZlLFxuICAgKiB0aGlzIHdpbGwgZ2VuZXJhdGUgNCBmaWxsZXIgZGF5cyAoMCwgMSwgMiwgMyksIGFuZCB0aGVuIGRheSBvZiB3ZWVrIDQgd2lsbCBoYXZlXG4gICAqIHRoZSBmaXJzdCBkYXkgb2YgdGhlIG1vbnRoLlxuICAgKlxuICAgKiAyLiBJZiBmaXJzdE9mTW9udGggPSAyLCBmaXJzdERheU9mV2VlayA9IDQgdGhlbiB0aGUgb2Zmc2V0XG4gICAqIGlzICg2IC0gKDQgLSAyKSkgPSA0LiBTaW5jZSB0aGUgb2Zmc2V0IGxvb3AgZ29lcyBmcm9tIDAgdG8gNCBpbmNsdXNpdmUsXG4gICAqIHRoaXMgd2lsbCBnZW5lcmF0ZSA1IGZpbGxlciBkYXlzICgwLCAxLCAyLCAzLCA0KSwgYW5kIHRoZW4gZGF5IG9mIHdlZWsgNSB3aWxsIGhhdmVcbiAgICogdGhlIGZpcnN0IGRheSBvZiB0aGUgbW9udGguXG4gICAqL1xuICBjb25zdCBvZmZzZXQgPSBmaXJzdE9mTW9udGggPj0gZmlyc3REYXlPZldlZWsgPyBmaXJzdE9mTW9udGggLSAoZmlyc3REYXlPZldlZWsgKyAxKSA6IDYgLSAoZmlyc3REYXlPZldlZWsgLSBmaXJzdE9mTW9udGgpO1xuICBsZXQgZGF5cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8PSBudW1EYXlzOyBpKyspIHtcbiAgICBkYXlzLnB1c2goeyBkYXk6IGksIGRheU9mV2VlazogKG9mZnNldCArIGkpICUgNyB9KTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8PSBvZmZzZXQ7IGkrKykge1xuICAgIGRheXMgPSBbeyBkYXk6IG51bGwsIGRheU9mV2VlazogbnVsbCB9LCAuLi5kYXlzXTtcbiAgfVxuICByZXR1cm4gZGF5cztcbn07XG4vKipcbiAqIEdpdmVuIGEgbG9jYWwsIHJlZmVyZW5jZSBkYXRldGltZSBwYXJ0cyBhbmQgb3B0aW9uXG4gKiBtYXgvbWluIGJvdW5kIGRhdGV0aW1lIHBhcnRzLCBjYWxjdWxhdGUgdGhlIGFjY2VwdGFibGVcbiAqIGhvdXIgYW5kIG1pbnV0ZSB2YWx1ZXMgYWNjb3JkaW5nIHRvIHRoZSBib3VuZHMgYW5kIGxvY2FsZS5cbiAqL1xuY29uc3QgZ2VuZXJhdGVUaW1lID0gKHJlZlBhcnRzLCBob3VyQ3ljbGUgPSAnaDEyJywgbWluUGFydHMsIG1heFBhcnRzLCBob3VyVmFsdWVzLCBtaW51dGVWYWx1ZXMpID0+IHtcbiAgY29uc3QgdXNlMjRIb3VyID0gaG91ckN5Y2xlID09PSAnaDIzJztcbiAgbGV0IHByb2Nlc3NlZEhvdXJzID0gdXNlMjRIb3VyID8gaG91cjIzIDogaG91cjEyO1xuICBsZXQgcHJvY2Vzc2VkTWludXRlcyA9IG1pbnV0ZXM7XG4gIGxldCBpc0FNQWxsb3dlZCA9IHRydWU7XG4gIGxldCBpc1BNQWxsb3dlZCA9IHRydWU7XG4gIGlmIChob3VyVmFsdWVzKSB7XG4gICAgcHJvY2Vzc2VkSG91cnMgPSBwcm9jZXNzZWRIb3Vycy5maWx0ZXIoKGhvdXIpID0+IGhvdXJWYWx1ZXMuaW5jbHVkZXMoaG91cikpO1xuICB9XG4gIGlmIChtaW51dGVWYWx1ZXMpIHtcbiAgICBwcm9jZXNzZWRNaW51dGVzID0gcHJvY2Vzc2VkTWludXRlcy5maWx0ZXIoKG1pbnV0ZSkgPT4gbWludXRlVmFsdWVzLmluY2x1ZGVzKG1pbnV0ZSkpO1xuICB9XG4gIGlmIChtaW5QYXJ0cykge1xuICAgIC8qKlxuICAgICAqIElmIHJlZiBkYXkgaXMgdGhlIHNhbWUgYXMgdGhlXG4gICAgICogbWluaW11bSBhbGxvd2VkIGRheSwgZmlsdGVyIGhvdXIvbWludXRlXG4gICAgICogdmFsdWVzIGFjY29yZGluZyB0byBtaW4gaG91ciBhbmQgbWludXRlLlxuICAgICAqL1xuICAgIGlmIChpc1NhbWVEYXkocmVmUGFydHMsIG1pblBhcnRzKSkge1xuICAgICAgLyoqXG4gICAgICAgKiBVc2VycyBtYXkgbm90IGFsd2F5cyBzZXQgdGhlIGhvdXIvbWludXRlIGZvclxuICAgICAgICogbWluIHZhbHVlIChpLmUuIDIwMjEtMDYtMDIpIHNvIHdlIHNob3VsZCBhbGxvd1xuICAgICAgICogYWxsIGhvdXJzL21pbnV0ZXMgaW4gdGhhdCBjYXNlLlxuICAgICAgICovXG4gICAgICBpZiAobWluUGFydHMuaG91ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb2Nlc3NlZEhvdXJzID0gcHJvY2Vzc2VkSG91cnMuZmlsdGVyKChob3VyKSA9PiB7XG4gICAgICAgICAgY29uc3QgY29udmVydGVkSG91ciA9IHJlZlBhcnRzLmFtcG0gPT09ICdwbScgPyAoaG91ciArIDEyKSAlIDI0IDogaG91cjtcbiAgICAgICAgICByZXR1cm4gKHVzZTI0SG91ciA/IGhvdXIgOiBjb252ZXJ0ZWRIb3VyKSA+PSBtaW5QYXJ0cy5ob3VyO1xuICAgICAgICB9KTtcbiAgICAgICAgaXNBTUFsbG93ZWQgPSBtaW5QYXJ0cy5ob3VyIDwgMTM7XG4gICAgICB9XG4gICAgICBpZiAobWluUGFydHMubWludXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtaW5pbXVtIG1pbnV0ZSByYW5nZSBzaG91bGQgbm90IGJlIGVuZm9yY2VkIHdoZW5cbiAgICAgICAgICogdGhlIGhvdXIgaXMgZ3JlYXRlciB0aGFuIHRoZSBtaW4gaG91ci5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIGV4YW1wbGUgd2l0aCBhIG1pbmltdW0gcmFuZ2Ugb2YgMDk6MzAsIHVzZXJzXG4gICAgICAgICAqIHNob3VsZCBiZSBhYmxlIHRvIHNlbGVjdCAxMDowMC0xMDoyOSBhbmQgYmV5b25kLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGlzUGFzdE1pbkhvdXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1pblBhcnRzLmhvdXIgIT09IHVuZGVmaW5lZCAmJiByZWZQYXJ0cy5ob3VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAocmVmUGFydHMuaG91ciA+IG1pblBhcnRzLmhvdXIpIHtcbiAgICAgICAgICAgIGlzUGFzdE1pbkhvdXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzZWRNaW51dGVzID0gcHJvY2Vzc2VkTWludXRlcy5maWx0ZXIoKG1pbnV0ZSkgPT4ge1xuICAgICAgICAgIGlmIChpc1Bhc3RNaW5Ib3VyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1pbnV0ZSA+PSBtaW5QYXJ0cy5taW51dGU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBJZiByZWYgZGF5IGlzIGJlZm9yZSBtaW5pbXVtXG4gICAgICAgKiBkYXkgZG8gbm90IHJlbmRlciBhbnkgaG91cnMvbWludXRlIHZhbHVlc1xuICAgICAgICovXG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQmVmb3JlKHJlZlBhcnRzLCBtaW5QYXJ0cykpIHtcbiAgICAgIHByb2Nlc3NlZEhvdXJzID0gW107XG4gICAgICBwcm9jZXNzZWRNaW51dGVzID0gW107XG4gICAgICBpc0FNQWxsb3dlZCA9IGlzUE1BbGxvd2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChtYXhQYXJ0cykge1xuICAgIC8qKlxuICAgICAqIElmIHJlZiBkYXkgaXMgdGhlIHNhbWUgYXMgdGhlXG4gICAgICogbWF4aW11bSBhbGxvd2VkIGRheSwgZmlsdGVyIGhvdXIvbWludXRlXG4gICAgICogdmFsdWVzIGFjY29yZGluZyB0byBtYXggaG91ciBhbmQgbWludXRlLlxuICAgICAqL1xuICAgIGlmIChpc1NhbWVEYXkocmVmUGFydHMsIG1heFBhcnRzKSkge1xuICAgICAgLyoqXG4gICAgICAgKiBVc2VycyBtYXkgbm90IGFsd2F5cyBzZXQgdGhlIGhvdXIvbWludXRlIGZvclxuICAgICAgICogbWF4IHZhbHVlIChpLmUuIDIwMjEtMDYtMDIpIHNvIHdlIHNob3VsZCBhbGxvd1xuICAgICAgICogYWxsIGhvdXJzL21pbnV0ZXMgaW4gdGhhdCBjYXNlLlxuICAgICAgICovXG4gICAgICBpZiAobWF4UGFydHMuaG91ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb2Nlc3NlZEhvdXJzID0gcHJvY2Vzc2VkSG91cnMuZmlsdGVyKChob3VyKSA9PiB7XG4gICAgICAgICAgY29uc3QgY29udmVydGVkSG91ciA9IHJlZlBhcnRzLmFtcG0gPT09ICdwbScgPyAoaG91ciArIDEyKSAlIDI0IDogaG91cjtcbiAgICAgICAgICByZXR1cm4gKHVzZTI0SG91ciA/IGhvdXIgOiBjb252ZXJ0ZWRIb3VyKSA8PSBtYXhQYXJ0cy5ob3VyO1xuICAgICAgICB9KTtcbiAgICAgICAgaXNQTUFsbG93ZWQgPSBtYXhQYXJ0cy5ob3VyID49IDEzO1xuICAgICAgfVxuICAgICAgaWYgKG1heFBhcnRzLm1pbnV0ZSAhPT0gdW5kZWZpbmVkICYmIHJlZlBhcnRzLmhvdXIgPT09IG1heFBhcnRzLmhvdXIpIHtcbiAgICAgICAgLy8gVGhlIGF2YWlsYWJsZSBtaW51dGVzIHNob3VsZCBvbmx5IGJlIGZpbHRlcmVkIHdoZW4gdGhlIGhvdXIgaXMgdGhlIHNhbWUgYXMgdGhlIG1heCBob3VyLlxuICAgICAgICAvLyBGb3IgZXhhbXBsZSBpZiB0aGUgbWF4IGhvdXIgaXMgMTA6MzAgYW5kIHRoZSBjdXJyZW50IGhvdXIgaXMgMTA6MDAsXG4gICAgICAgIC8vIHVzZXJzIHNob3VsZCBiZSBhYmxlIHRvIHNlbGVjdCAwMC0zMCBtaW51dGVzLlxuICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBob3VyIGlzIDA5OjAwLCB1c2VycyBzaG91bGQgYmUgYWJsZSB0byBzZWxlY3QgMDAtNjAgbWludXRlcy5cbiAgICAgICAgcHJvY2Vzc2VkTWludXRlcyA9IHByb2Nlc3NlZE1pbnV0ZXMuZmlsdGVyKChtaW51dGUpID0+IG1pbnV0ZSA8PSBtYXhQYXJ0cy5taW51dGUpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBJZiByZWYgZGF5IGlzIGFmdGVyIG1pbmltdW1cbiAgICAgICAqIGRheSBkbyBub3QgcmVuZGVyIGFueSBob3Vycy9taW51dGUgdmFsdWVzXG4gICAgICAgKi9cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBZnRlcihyZWZQYXJ0cywgbWF4UGFydHMpKSB7XG4gICAgICBwcm9jZXNzZWRIb3VycyA9IFtdO1xuICAgICAgcHJvY2Vzc2VkTWludXRlcyA9IFtdO1xuICAgICAgaXNBTUFsbG93ZWQgPSBpc1BNQWxsb3dlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGhvdXJzOiBwcm9jZXNzZWRIb3VycyxcbiAgICBtaW51dGVzOiBwcm9jZXNzZWRNaW51dGVzLFxuICAgIGFtOiBpc0FNQWxsb3dlZCxcbiAgICBwbTogaXNQTUFsbG93ZWQsXG4gIH07XG59O1xuLyoqXG4gKiBHaXZlbiBEYXRldGltZVBhcnRzLCBnZW5lcmF0ZSB0aGUgcHJldmlvdXMsXG4gKiBjdXJyZW50LCBhbmQgYW5kIG5leHQgbW9udGhzLlxuICovXG5jb25zdCBnZW5lcmF0ZU1vbnRocyA9IChyZWZQYXJ0cykgPT4ge1xuICByZXR1cm4gW1xuICAgIGdldFByZXZpb3VzTW9udGgocmVmUGFydHMpLFxuICAgIHsgbW9udGg6IHJlZlBhcnRzLm1vbnRoLCB5ZWFyOiByZWZQYXJ0cy55ZWFyLCBkYXk6IHJlZlBhcnRzLmRheSB9LFxuICAgIGdldE5leHRNb250aChyZWZQYXJ0cyksXG4gIF07XG59O1xuY29uc3QgZ2V0TW9udGhDb2x1bW5EYXRhID0gKGxvY2FsZSwgcmVmUGFydHMsIG1pblBhcnRzLCBtYXhQYXJ0cywgbW9udGhWYWx1ZXMsIGZvcm1hdE9wdGlvbnMgPSB7XG4gIG1vbnRoOiAnbG9uZycsXG59KSA9PiB7XG4gIGNvbnN0IHsgeWVhciB9ID0gcmVmUGFydHM7XG4gIGNvbnN0IG1vbnRocyA9IFtdO1xuICBpZiAobW9udGhWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGxldCBwcm9jZXNzZWRNb250aHMgPSBtb250aFZhbHVlcztcbiAgICBpZiAoKG1heFBhcnRzID09PSBudWxsIHx8IG1heFBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXhQYXJ0cy5tb250aCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJvY2Vzc2VkTW9udGhzID0gcHJvY2Vzc2VkTW9udGhzLmZpbHRlcigobW9udGgpID0+IG1vbnRoIDw9IG1heFBhcnRzLm1vbnRoKTtcbiAgICB9XG4gICAgaWYgKChtaW5QYXJ0cyA9PT0gbnVsbCB8fCBtaW5QYXJ0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWluUGFydHMubW9udGgpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb2Nlc3NlZE1vbnRocyA9IHByb2Nlc3NlZE1vbnRocy5maWx0ZXIoKG1vbnRoKSA9PiBtb250aCA+PSBtaW5QYXJ0cy5tb250aCk7XG4gICAgfVxuICAgIHByb2Nlc3NlZE1vbnRocy5mb3JFYWNoKChwcm9jZXNzZWRNb250aCkgPT4ge1xuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke3Byb2Nlc3NlZE1vbnRofS8xLyR7eWVhcn0gR01UKzAwMDBgKTtcbiAgICAgIGNvbnN0IG1vbnRoU3RyaW5nID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZvcm1hdE9wdGlvbnMpLCB7IHRpbWVab25lOiAnVVRDJyB9KSkuZm9ybWF0KGRhdGUpO1xuICAgICAgbW9udGhzLnB1c2goeyB0ZXh0OiBtb250aFN0cmluZywgdmFsdWU6IHByb2Nlc3NlZE1vbnRoIH0pO1xuICAgIH0pO1xuICB9XG4gIGVsc2Uge1xuICAgIGNvbnN0IG1heE1vbnRoID0gbWF4UGFydHMgJiYgbWF4UGFydHMueWVhciA9PT0geWVhciA/IG1heFBhcnRzLm1vbnRoIDogMTI7XG4gICAgY29uc3QgbWluTW9udGggPSBtaW5QYXJ0cyAmJiBtaW5QYXJ0cy55ZWFyID09PSB5ZWFyID8gbWluUGFydHMubW9udGggOiAxO1xuICAgIGZvciAobGV0IGkgPSBtaW5Nb250aDsgaSA8PSBtYXhNb250aDsgaSsrKSB7XG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBUaGVyZSBpcyBhIGJ1ZyBvbiBpT1MgMTQgd2hlcmVcbiAgICAgICAqIEludGwuRGF0ZVRpbWVGb3JtYXQgdGFrZXMgaW50byBhY2NvdW50XG4gICAgICAgKiB0aGUgbG9jYWwgdGltZXpvbmUgb2Zmc2V0IHdoZW4gZm9ybWF0dGluZyBkYXRlcy5cbiAgICAgICAqXG4gICAgICAgKiBGb3JjaW5nIHRoZSB0aW1lem9uZSB0byAnVVRDJyBmaXhlcyB0aGUgaXNzdWUuIEhvd2V2ZXIsXG4gICAgICAgKiB3ZSBzaG91bGQga2VlcCB0aGlzIHdvcmthcm91bmQgYXMgaXQgaXMgc2FmZXIuIEluIHRoZSBldmVudFxuICAgICAgICogdGhpcyBicmVha3MgaW4gYW5vdGhlciBicm93c2VyLCB3ZSB3aWxsIG5vdCBiZSBpbXBhY3RlZFxuICAgICAgICogYmVjYXVzZSBhbGwgZGF0ZXMgd2lsbCBiZSBpbnRlcnByZXRlZCBpbiBVVEMuXG4gICAgICAgKlxuICAgICAgICogRXhhbXBsZTpcbiAgICAgICAqIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCdlbi1VUycsIHsgbW9udGg6ICdsb25nJyB9KS5mb3JtYXQobmV3IERhdGUoJ1NhdCBBcHIgMDEgMjAwNiAwMDowMDowMCBHTVQtMDQwMCAoRURUKScpKSAvLyBcIk1hcmNoXCJcbiAgICAgICAqIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCdlbi1VUycsIHsgbW9udGg6ICdsb25nJywgdGltZVpvbmU6ICdVVEMnIH0pLmZvcm1hdChuZXcgRGF0ZSgnU2F0IEFwciAwMSAyMDA2IDAwOjAwOjAwIEdNVC0wNDAwIChFRFQpJykpIC8vIFwiQXByaWxcIlxuICAgICAgICpcbiAgICAgICAqIEluIGNlcnRhaW4gdGltZXpvbmVzLCBpT1MgMTQgc2hvd3MgdGhlIHdyb25nXG4gICAgICAgKiBkYXRlIGZvciAudG9VVENTdHJpbmcoKS4gVG8gY29tYmF0IHRoaXMsIHdlXG4gICAgICAgKiBmb3JjZSBhbGwgb2YgdGhlIHRpbWV6b25lcyB0byBHTVQrMDAwMCAoVVRDKS5cbiAgICAgICAqXG4gICAgICAgKiBFeGFtcGxlOlxuICAgICAgICogVGltZSBab25lOiBDZW50cmFsIEV1cm9wZWFuIFN0YW5kYXJkIFRpbWVcbiAgICAgICAqIG5ldyBEYXRlKCcxLzEvMTk5MicpLnRvVVRDU3RyaW5nKCkgLy8gXCJUdWUsIDMxIERlYyAxOTkxIDIzOjAwOjAwIEdNVFwiXG4gICAgICAgKiBuZXcgRGF0ZSgnMS8xLzE5OTIgR01UKzAwMDAnKS50b1VUQ1N0cmluZygpIC8vIFwiV2VkLCAwMSBKYW4gMTk5MiAwMDowMDowMCBHTVRcIlxuICAgICAgICovXG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoYCR7aX0vMS8ke3llYXJ9IEdNVCswMDAwYCk7XG4gICAgICBjb25zdCBtb250aFN0cmluZyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmb3JtYXRPcHRpb25zKSwgeyB0aW1lWm9uZTogJ1VUQycgfSkpLmZvcm1hdChkYXRlKTtcbiAgICAgIG1vbnRocy5wdXNoKHsgdGV4dDogbW9udGhTdHJpbmcsIHZhbHVlOiBpIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9udGhzO1xufTtcbi8qKlxuICogUmV0dXJucyBpbmZvcm1hdGlvbiByZWdhcmRpbmdcbiAqIHNlbGVjdGFibGUgZGF0ZXMgKGkuZSAxc3QsIDJuZCwgM3JkLCBldGMpXG4gKiB3aXRoaW4gYSByZWZlcmVuY2UgbW9udGguXG4gKiBAcGFyYW0gbG9jYWxlIFRoZSBsb2NhbGUgdG8gZm9ybWF0IHRoZSBkYXRlIHdpdGhcbiAqIEBwYXJhbSByZWZQYXJ0cyBUaGUgcmVmZXJlbmNlIG1vbnRoL3llYXIgdG8gZ2VuZXJhdGUgZGF0ZXMgZm9yXG4gKiBAcGFyYW0gbWluUGFydHMgVGhlIG1pbmltdW0gYm91bmQgb24gdGhlIGRhdGUgdGhhdCBjYW4gYmUgcmV0dXJuZWRcbiAqIEBwYXJhbSBtYXhQYXJ0cyBUaGUgbWF4aW11bSBib3VuZCBvbiB0aGUgZGF0ZSB0aGF0IGNhbiBiZSByZXR1cm5lZFxuICogQHBhcmFtIGRheVZhbHVlcyBUaGUgYWxsb3dlZCBkYXRlIHZhbHVlc1xuICogQHJldHVybnMgRGF0ZSBkYXRhIHRvIGJlIHVzZWQgaW4gaW9uLXBpY2tlci1jb2x1bW4taW50ZXJuYWxcbiAqL1xuY29uc3QgZ2V0RGF5Q29sdW1uRGF0YSA9IChsb2NhbGUsIHJlZlBhcnRzLCBtaW5QYXJ0cywgbWF4UGFydHMsIGRheVZhbHVlcywgZm9ybWF0T3B0aW9ucyA9IHtcbiAgZGF5OiAnbnVtZXJpYycsXG59KSA9PiB7XG4gIGNvbnN0IHsgbW9udGgsIHllYXIgfSA9IHJlZlBhcnRzO1xuICBjb25zdCBkYXlzID0gW107XG4gIC8qKlxuICAgKiBJZiB3ZSBoYXZlIG1heC9taW4gYm91bmRzIHRoYXQgaW4gdGhlIHNhbWVcbiAgICogbW9udGgveWVhciBhcyB0aGUgcmVmUGFydHMsIHdlIHNob3VsZFxuICAgKiB1c2UgdGhlIGRlZmluZSBkYXkgYXMgdGhlIG1heC9taW4gZGF5LlxuICAgKiBPdGhlcndpc2UsIGZhbGxiYWNrIHRvIHRoZSBtYXgvbWluIGRheXMgaW4gYSBtb250aC5cbiAgICovXG4gIGNvbnN0IG51bURheXNJbk1vbnRoID0gZ2V0TnVtRGF5c0luTW9udGgobW9udGgsIHllYXIpO1xuICBjb25zdCBtYXhEYXkgPSAobWF4UGFydHMgPT09IG51bGwgfHwgbWF4UGFydHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1heFBhcnRzLmRheSkgIT09IG51bGwgJiYgKG1heFBhcnRzID09PSBudWxsIHx8IG1heFBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXhQYXJ0cy5kYXkpICE9PSB1bmRlZmluZWQgJiYgbWF4UGFydHMueWVhciA9PT0geWVhciAmJiBtYXhQYXJ0cy5tb250aCA9PT0gbW9udGhcbiAgICA/IG1heFBhcnRzLmRheVxuICAgIDogbnVtRGF5c0luTW9udGg7XG4gIGNvbnN0IG1pbkRheSA9IChtaW5QYXJ0cyA9PT0gbnVsbCB8fCBtaW5QYXJ0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWluUGFydHMuZGF5KSAhPT0gbnVsbCAmJiAobWluUGFydHMgPT09IG51bGwgfHwgbWluUGFydHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1pblBhcnRzLmRheSkgIT09IHVuZGVmaW5lZCAmJiBtaW5QYXJ0cy55ZWFyID09PSB5ZWFyICYmIG1pblBhcnRzLm1vbnRoID09PSBtb250aFxuICAgID8gbWluUGFydHMuZGF5XG4gICAgOiAxO1xuICBpZiAoZGF5VmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgcHJvY2Vzc2VkRGF5cyA9IGRheVZhbHVlcztcbiAgICBwcm9jZXNzZWREYXlzID0gcHJvY2Vzc2VkRGF5cy5maWx0ZXIoKGRheSkgPT4gZGF5ID49IG1pbkRheSAmJiBkYXkgPD0gbWF4RGF5KTtcbiAgICBwcm9jZXNzZWREYXlzLmZvckVhY2goKHByb2Nlc3NlZERheSkgPT4ge1xuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke21vbnRofS8ke3Byb2Nlc3NlZERheX0vJHt5ZWFyfSBHTVQrMDAwMGApO1xuICAgICAgY29uc3QgZGF5U3RyaW5nID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZvcm1hdE9wdGlvbnMpLCB7IHRpbWVab25lOiAnVVRDJyB9KSkuZm9ybWF0KGRhdGUpO1xuICAgICAgZGF5cy5wdXNoKHsgdGV4dDogZGF5U3RyaW5nLCB2YWx1ZTogcHJvY2Vzc2VkRGF5IH0pO1xuICAgIH0pO1xuICB9XG4gIGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSBtaW5EYXk7IGkgPD0gbWF4RGF5OyBpKyspIHtcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShgJHttb250aH0vJHtpfS8ke3llYXJ9IEdNVCswMDAwYCk7XG4gICAgICBjb25zdCBkYXlTdHJpbmcgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZm9ybWF0T3B0aW9ucyksIHsgdGltZVpvbmU6ICdVVEMnIH0pKS5mb3JtYXQoZGF0ZSk7XG4gICAgICBkYXlzLnB1c2goeyB0ZXh0OiBkYXlTdHJpbmcsIHZhbHVlOiBpIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF5cztcbn07XG5jb25zdCBnZXRZZWFyQ29sdW1uRGF0YSA9IChsb2NhbGUsIHJlZlBhcnRzLCBtaW5QYXJ0cywgbWF4UGFydHMsIHllYXJWYWx1ZXMpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgbGV0IHByb2Nlc3NlZFllYXJzID0gW107XG4gIGlmICh5ZWFyVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBwcm9jZXNzZWRZZWFycyA9IHllYXJWYWx1ZXM7XG4gICAgaWYgKChtYXhQYXJ0cyA9PT0gbnVsbCB8fCBtYXhQYXJ0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF4UGFydHMueWVhcikgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJvY2Vzc2VkWWVhcnMgPSBwcm9jZXNzZWRZZWFycy5maWx0ZXIoKHllYXIpID0+IHllYXIgPD0gbWF4UGFydHMueWVhcik7XG4gICAgfVxuICAgIGlmICgobWluUGFydHMgPT09IG51bGwgfHwgbWluUGFydHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1pblBhcnRzLnllYXIpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb2Nlc3NlZFllYXJzID0gcHJvY2Vzc2VkWWVhcnMuZmlsdGVyKCh5ZWFyKSA9PiB5ZWFyID49IG1pblBhcnRzLnllYXIpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBjb25zdCB7IHllYXIgfSA9IHJlZlBhcnRzO1xuICAgIGNvbnN0IG1heFllYXIgPSAoX2EgPSBtYXhQYXJ0cyA9PT0gbnVsbCB8fCBtYXhQYXJ0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF4UGFydHMueWVhcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogeWVhcjtcbiAgICBjb25zdCBtaW5ZZWFyID0gKF9iID0gbWluUGFydHMgPT09IG51bGwgfHwgbWluUGFydHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1pblBhcnRzLnllYXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHllYXIgLSAxMDA7XG4gICAgZm9yIChsZXQgaSA9IG1heFllYXI7IGkgPj0gbWluWWVhcjsgaS0tKSB7XG4gICAgICBwcm9jZXNzZWRZZWFycy5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvY2Vzc2VkWWVhcnMubWFwKCh5ZWFyKSA9PiAoe1xuICAgIHRleHQ6IGdldFllYXIobG9jYWxlLCB7IHllYXIsIG1vbnRoOiByZWZQYXJ0cy5tb250aCwgZGF5OiByZWZQYXJ0cy5kYXkgfSksXG4gICAgdmFsdWU6IHllYXIsXG4gIH0pKTtcbn07XG4vKipcbiAqIEdpdmVuIGEgc3RhcnRpbmcgZGF0ZSBhbmQgYW4gdXBwZXIgYm91bmQsXG4gKiB0aGlzIGZ1bmN0aW9ucyByZXR1cm5zIGFuIGFycmF5IG9mIGFsbFxuICogbW9udGggb2JqZWN0cyBpbiB0aGF0IHJhbmdlLlxuICovXG5jb25zdCBnZXRBbGxNb250aHNJblJhbmdlID0gKGN1cnJlbnRQYXJ0cywgbWF4UGFydHMpID0+IHtcbiAgaWYgKGN1cnJlbnRQYXJ0cy5tb250aCA9PT0gbWF4UGFydHMubW9udGggJiYgY3VycmVudFBhcnRzLnllYXIgPT09IG1heFBhcnRzLnllYXIpIHtcbiAgICByZXR1cm4gW2N1cnJlbnRQYXJ0c107XG4gIH1cbiAgcmV0dXJuIFtjdXJyZW50UGFydHMsIC4uLmdldEFsbE1vbnRoc0luUmFuZ2UoZ2V0TmV4dE1vbnRoKGN1cnJlbnRQYXJ0cyksIG1heFBhcnRzKV07XG59O1xuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIHBpY2tlciBpdGVtc1xuICogdGhhdCByZXByZXNlbnQgdGhlIGRheXMgaW4gYSBtb250aC5cbiAqIEV4YW1wbGU6IFwiVGh1LCBKdW4gMlwiXG4gKi9cbmNvbnN0IGdldENvbWJpbmVkRGF0ZUNvbHVtbkRhdGEgPSAobG9jYWxlLCB0b2RheVBhcnRzLCBtaW5QYXJ0cywgbWF4UGFydHMsIGRheVZhbHVlcywgbW9udGhWYWx1ZXMpID0+IHtcbiAgbGV0IGl0ZW1zID0gW107XG4gIGxldCBwYXJ0cyA9IFtdO1xuICAvKipcbiAgICogR2V0IGFsbCBtb250aCBvYmplY3RzIGZyb20gdGhlIG1pbiBkYXRlXG4gICAqIHRvIHRoZSBtYXggZGF0ZS4gTm90ZTogRG8gbm90IHVzZSBnZXRNb250aENvbHVtbkRhdGFcbiAgICogYXMgdGhhdCBmdW5jdGlvbiBvbmx5IGdlbmVyYXRlcyBkYXRlcyB3aXRoaW4gYVxuICAgKiBzaW5nbGUgeWVhci5cbiAgICovXG4gIGxldCBtb250aHMgPSBnZXRBbGxNb250aHNJblJhbmdlKG1pblBhcnRzLCBtYXhQYXJ0cyk7XG4gIC8qKlxuICAgKiBGaWx0ZXIgb3V0IGFueSBkaXNhbGxvd2VkIG1vbnRoIHZhbHVlcy5cbiAgICovXG4gIGlmIChtb250aFZhbHVlcykge1xuICAgIG1vbnRocyA9IG1vbnRocy5maWx0ZXIoKHsgbW9udGggfSkgPT4gbW9udGhWYWx1ZXMuaW5jbHVkZXMobW9udGgpKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFsbCBvZiB0aGUgZGF5cyBpbiB0aGUgbW9udGguXG4gICAqIEZyb20gdGhlcmUsIGdlbmVyYXRlIGFuIGFycmF5IHdoZXJlXG4gICAqIGVhY2ggaXRlbSBoYXMgdGhlIG1vbnRoLCBkYXRlLCBhbmQgZGF5XG4gICAqIG9mIHdvcmsgYXMgdGhlIHRleHQuXG4gICAqL1xuICBtb250aHMuZm9yRWFjaCgobW9udGhPYmplY3QpID0+IHtcbiAgICBjb25zdCByZWZlcmVuY2VNb250aCA9IHsgbW9udGg6IG1vbnRoT2JqZWN0Lm1vbnRoLCBkYXk6IG51bGwsIHllYXI6IG1vbnRoT2JqZWN0LnllYXIgfTtcbiAgICBjb25zdCBtb250aERheXMgPSBnZXREYXlDb2x1bW5EYXRhKGxvY2FsZSwgcmVmZXJlbmNlTW9udGgsIG1pblBhcnRzLCBtYXhQYXJ0cywgZGF5VmFsdWVzLCB7XG4gICAgICBtb250aDogJ3Nob3J0JyxcbiAgICAgIGRheTogJ251bWVyaWMnLFxuICAgICAgd2Vla2RheTogJ3Nob3J0JyxcbiAgICB9KTtcbiAgICBjb25zdCBkYXRlUGFydHMgPSBbXTtcbiAgICBjb25zdCBkYXRlQ29sdW1uSXRlbXMgPSBbXTtcbiAgICBtb250aERheXMuZm9yRWFjaCgoZGF5T2JqZWN0KSA9PiB7XG4gICAgICBjb25zdCBpc1RvZGF5ID0gaXNTYW1lRGF5KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVmZXJlbmNlTW9udGgpLCB7IGRheTogZGF5T2JqZWN0LnZhbHVlIH0pLCB0b2RheVBhcnRzKTtcbiAgICAgIC8qKlxuICAgICAgICogVG9kYXkncyBkYXRlIHNob3VsZCByZWFkIGFzIFwiVG9kYXlcIiAobG9jYWxpemVkKVxuICAgICAgICogbm90IHRoZSBhY3R1YWwgZGF0ZSBzdHJpbmdcbiAgICAgICAqL1xuICAgICAgZGF0ZUNvbHVtbkl0ZW1zLnB1c2goe1xuICAgICAgICB0ZXh0OiBpc1RvZGF5ID8gZ2V0VG9kYXlMYWJlbChsb2NhbGUpIDogZGF5T2JqZWN0LnRleHQsXG4gICAgICAgIHZhbHVlOiBgJHtyZWZlcmVuY2VNb250aC55ZWFyfS0ke3JlZmVyZW5jZU1vbnRoLm1vbnRofS0ke2RheU9iamVjdC52YWx1ZX1gLFxuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gc2VsZWN0aW5nIGEgZGF0ZSBpbiB0aGUgd2hlZWwgcGlja2VyXG4gICAgICAgKiB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgcmF3IGRhdGV0aW1lIHBhcnRzIGRhdGEuXG4gICAgICAgKiBUaGUgcGlja2VyIGNvbHVtbiBvbmx5IGFjY2VwdHMgdmFsdWVzIG9mXG4gICAgICAgKiB0eXBlIHN0cmluZyBvciBudW1iZXIsIHNvIHdlIG5lZWQgdG8gcmV0dXJuXG4gICAgICAgKiB0d28gc2V0cyBvZiBkYXRhOiBBIGRhdGEgc2V0IHRvIGJlIHBhc3NlZFxuICAgICAgICogdG8gdGhlIHBpY2tlciBjb2x1bW4sIGFuZCBhIGRhdGEgc2V0IHRvXG4gICAgICAgKiBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGUgcmF3IGRhdGEgd2hlblxuICAgICAgICogdXBkYXRpbmcgdGhlIHBpY2tlciBjb2x1bW4gdmFsdWUuXG4gICAgICAgKi9cbiAgICAgIGRhdGVQYXJ0cy5wdXNoKHtcbiAgICAgICAgbW9udGg6IHJlZmVyZW5jZU1vbnRoLm1vbnRoLFxuICAgICAgICB5ZWFyOiByZWZlcmVuY2VNb250aC55ZWFyLFxuICAgICAgICBkYXk6IGRheU9iamVjdC52YWx1ZSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHBhcnRzID0gWy4uLnBhcnRzLCAuLi5kYXRlUGFydHNdO1xuICAgIGl0ZW1zID0gWy4uLml0ZW1zLCAuLi5kYXRlQ29sdW1uSXRlbXNdO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwYXJ0cyxcbiAgICBpdGVtcyxcbiAgfTtcbn07XG5jb25zdCBnZXRUaW1lQ29sdW1uc0RhdGEgPSAobG9jYWxlLCByZWZQYXJ0cywgaG91ckN5Y2xlLCBtaW5QYXJ0cywgbWF4UGFydHMsIGFsbG93ZWRIb3VyVmFsdWVzLCBhbGxvd2VkTWludXRlVmF1ZXMpID0+IHtcbiAgY29uc3QgdXNlMjRIb3VyID0gaXMyNEhvdXIobG9jYWxlLCBob3VyQ3ljbGUpO1xuICBjb25zdCB7IGhvdXJzLCBtaW51dGVzLCBhbSwgcG0gfSA9IGdlbmVyYXRlVGltZShyZWZQYXJ0cywgdXNlMjRIb3VyID8gJ2gyMycgOiAnaDEyJywgbWluUGFydHMsIG1heFBhcnRzLCBhbGxvd2VkSG91clZhbHVlcywgYWxsb3dlZE1pbnV0ZVZhdWVzKTtcbiAgY29uc3QgaG91cnNJdGVtcyA9IGhvdXJzLm1hcCgoaG91cikgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiBnZXRGb3JtYXR0ZWRIb3VyKGhvdXIsIHVzZTI0SG91ciksXG4gICAgICB2YWx1ZTogZ2V0SW50ZXJuYWxIb3VyVmFsdWUoaG91ciwgdXNlMjRIb3VyLCByZWZQYXJ0cy5hbXBtKSxcbiAgICB9O1xuICB9KTtcbiAgY29uc3QgbWludXRlc0l0ZW1zID0gbWludXRlcy5tYXAoKG1pbnV0ZSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiBhZGRUaW1lUGFkZGluZyhtaW51dGUpLFxuICAgICAgdmFsdWU6IG1pbnV0ZSxcbiAgICB9O1xuICB9KTtcbiAgY29uc3QgZGF5UGVyaW9kSXRlbXMgPSBbXTtcbiAgaWYgKGFtICYmICF1c2UyNEhvdXIpIHtcbiAgICBkYXlQZXJpb2RJdGVtcy5wdXNoKHtcbiAgICAgIHRleHQ6IGdldExvY2FsaXplZERheVBlcmlvZChsb2NhbGUsICdhbScpLFxuICAgICAgdmFsdWU6ICdhbScsXG4gICAgfSk7XG4gIH1cbiAgaWYgKHBtICYmICF1c2UyNEhvdXIpIHtcbiAgICBkYXlQZXJpb2RJdGVtcy5wdXNoKHtcbiAgICAgIHRleHQ6IGdldExvY2FsaXplZERheVBlcmlvZChsb2NhbGUsICdwbScpLFxuICAgICAgdmFsdWU6ICdwbScsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtaW51dGVzRGF0YTogbWludXRlc0l0ZW1zLFxuICAgIGhvdXJzRGF0YTogaG91cnNJdGVtcyxcbiAgICBkYXlQZXJpb2REYXRhOiBkYXlQZXJpb2RJdGVtcyxcbiAgfTtcbn07XG5cbmNvbnN0IElTT184NjAxX1JFR0VYUCA9IFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4vXihcXGR7NH18WytcXC1dXFxkezZ9KSg/Oi0oXFxkezJ9KSg/Oi0oXFxkezJ9KSk/KT8oPzpUKFxcZHsyfSk6KFxcZHsyfSkoPzo6KFxcZHsyfSkoPzpcXC4oXFxkezN9KSk/KT8oPzooWil8KFsrXFwtXSkoXFxkezJ9KSg/OjooXFxkezJ9KSk/KT8pPyQvO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG5jb25zdCBUSU1FX1JFR0VYUCA9IC9eKChcXGR7Mn0pOihcXGR7Mn0pKD86OihcXGR7Mn0pKD86XFwuKFxcZHszfSkpPyk/KD86KFopfChbK1xcLV0pKFxcZHsyfSkoPzo6KFxcZHsyfSkpPyk/KT8kLztcbi8qKlxuICogVXNlIHRvIGNvbnZlcnQgYSBzdHJpbmcgb2YgY29tbWEgc2VwYXJhdGVkIG51bWJlcnMgb3JcbiAqIGFuIGFycmF5IG9mIG51bWJlcnMsIGFuZCBjbGVhbiB1cCBhbnkgdXNlciBpbnB1dFxuICovXG5jb25zdCBjb252ZXJ0VG9BcnJheU9mTnVtYmVycyA9IChpbnB1dCkgPT4ge1xuICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgcHJvY2Vzc2VkSW5wdXQgPSBpbnB1dDtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBjb252ZXJ0IHRoZSBzdHJpbmcgdG8gYW4gYXJyYXkgb2Ygc3RyaW5nc1xuICAgIC8vIGF1dG8gcmVtb3ZlIGFueSB3aGl0ZXNwYWNlIGFuZCBbXSBjaGFyYWN0ZXJzXG4gICAgcHJvY2Vzc2VkSW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9cXFt8XFxdfFxccy9nLCAnJykuc3BsaXQoJywnKTtcbiAgfVxuICBsZXQgdmFsdWVzO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9jZXNzZWRJbnB1dCkpIHtcbiAgICAvLyBlbnN1cmUgZWFjaCB2YWx1ZSBpcyBhbiBhY3R1YWwgbnVtYmVyIGluIHRoZSByZXR1cm5lZCBhcnJheVxuICAgIHZhbHVlcyA9IHByb2Nlc3NlZElucHV0Lm1hcCgobnVtKSA9PiBwYXJzZUludChudW0sIDEwKSkuZmlsdGVyKGlzRmluaXRlKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YWx1ZXMgPSBbcHJvY2Vzc2VkSW5wdXRdO1xuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59O1xuLyoqXG4gKiBFeHRyYWN0cyBkYXRlIGluZm9ybWF0aW9uXG4gKiBmcm9tIGEgLmNhbGVuZGFyLWRheSBlbGVtZW50XG4gKiBpbnRvIERhdGV0aW1lUGFydHMuXG4gKi9cbmNvbnN0IGdldFBhcnRzRnJvbUNhbGVuZGFyRGF5ID0gKGVsKSA9PiB7XG4gIHJldHVybiB7XG4gICAgbW9udGg6IHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1tb250aCcpLCAxMCksXG4gICAgZGF5OiBwYXJzZUludChlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGF5JyksIDEwKSxcbiAgICB5ZWFyOiBwYXJzZUludChlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEteWVhcicpLCAxMCksXG4gICAgZGF5T2ZXZWVrOiBwYXJzZUludChlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGF5LW9mLXdlZWsnKSwgMTApLFxuICB9O1xufTtcbmZ1bmN0aW9uIHBhcnNlRGF0ZSh2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiB2YWwubWFwKCh2YWxTdHIpID0+IHBhcnNlRGF0ZSh2YWxTdHIpKTtcbiAgfVxuICAvLyBtYW51YWxseSBwYXJzZSBJUzAgY3V6IERhdGUucGFyc2UgY2Fubm90IGJlIHRydXN0ZWRcbiAgLy8gSVNPIDg2MDEgZm9ybWF0OiAxOTk0LTEyLTE1VDEzOjQ3OjIwWlxuICBsZXQgcGFyc2UgPSBudWxsO1xuICBpZiAodmFsICE9IG51bGwgJiYgdmFsICE9PSAnJykge1xuICAgIC8vIHRyeSBwYXJzaW5nIGZvciBqdXN0IHRpbWUgZmlyc3QsIEhIOk1NXG4gICAgcGFyc2UgPSBUSU1FX1JFR0VYUC5leGVjKHZhbCk7XG4gICAgaWYgKHBhcnNlKSB7XG4gICAgICAvLyBhZGp1c3QgdGhlIGFycmF5IHNvIGl0IGZpdHMgbmljZWx5IHdpdGggdGhlIGRhdGV0aW1lIHBhcnNlXG4gICAgICBwYXJzZS51bnNoaWZ0KHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICAgIHBhcnNlWzJdID0gcGFyc2VbM10gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gdHJ5IHBhcnNpbmcgZm9yIGZ1bGwgSVNPIGRhdGV0aW1lXG4gICAgICBwYXJzZSA9IElTT184NjAxX1JFR0VYUC5leGVjKHZhbCk7XG4gICAgfVxuICB9XG4gIGlmIChwYXJzZSA9PT0gbnVsbCkge1xuICAgIC8vIHdhc24ndCBhYmxlIHRvIHBhcnNlIHRoZSBJU08gZGF0ZXRpbWVcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIC8vIGVuc3VyZSBhbGwgdGhlIHBhcnNlIHZhbHVlcyBleGlzdCB3aXRoIGF0IGxlYXN0IDBcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCA4OyBpKyspIHtcbiAgICBwYXJzZVtpXSA9IHBhcnNlW2ldICE9PSB1bmRlZmluZWQgPyBwYXJzZUludChwYXJzZVtpXSwgMTApIDogdW5kZWZpbmVkO1xuICB9XG4gIGxldCB0ek9mZnNldCA9IDA7XG4gIGlmIChwYXJzZVs5XSAmJiBwYXJzZVsxMF0pIHtcbiAgICAvLyBob3Vyc1xuICAgIHR6T2Zmc2V0ID0gcGFyc2VJbnQocGFyc2VbMTBdLCAxMCkgKiA2MDtcbiAgICBpZiAocGFyc2VbMTFdKSB7XG4gICAgICAvLyBtaW51dGVzXG4gICAgICB0ek9mZnNldCArPSBwYXJzZUludChwYXJzZVsxMV0sIDEwKTtcbiAgICB9XG4gICAgaWYgKHBhcnNlWzldID09PSAnLScpIHtcbiAgICAgIC8vICsgb3IgLVxuICAgICAgdHpPZmZzZXQgKj0gLTE7XG4gICAgfVxuICB9XG4gIC8vIGNhbiBhbHNvIGdldCBzZWNvbmQgYW5kIG1pbGxpc2Vjb25kIGZyb20gcGFyc2VbNl0gYW5kIHBhcnNlWzddIGlmIG5lZWRlZFxuICByZXR1cm4ge1xuICAgIHllYXI6IHBhcnNlWzFdLFxuICAgIG1vbnRoOiBwYXJzZVsyXSxcbiAgICBkYXk6IHBhcnNlWzNdLFxuICAgIGhvdXI6IHBhcnNlWzRdLFxuICAgIG1pbnV0ZTogcGFyc2VbNV0sXG4gICAgdHpPZmZzZXQsXG4gICAgYW1wbTogcGFyc2VbNF0gPCAxMiA/ICdhbScgOiAncG0nLFxuICB9O1xufVxuY29uc3QgY2xhbXBEYXRlID0gKGRhdGVQYXJ0cywgbWluUGFydHMsIG1heFBhcnRzKSA9PiB7XG4gIGlmIChtaW5QYXJ0cyAmJiBpc0JlZm9yZShkYXRlUGFydHMsIG1pblBhcnRzKSkge1xuICAgIHJldHVybiBtaW5QYXJ0cztcbiAgfVxuICBlbHNlIGlmIChtYXhQYXJ0cyAmJiBpc0FmdGVyKGRhdGVQYXJ0cywgbWF4UGFydHMpKSB7XG4gICAgcmV0dXJuIG1heFBhcnRzO1xuICB9XG4gIHJldHVybiBkYXRlUGFydHM7XG59O1xuLyoqXG4gKiBQYXJzZXMgYW4gaG91ciBhbmQgcmV0dXJucyBpZiB0aGUgdmFsdWUgaXMgaW4gdGhlIG1vcm5pbmcgKGFtKSBvciBhZnRlcm5vb24gKHBtKS5cbiAqIEBwYXJhbSBob3VyIFRoZSBob3VyIHRvIGZvcm1hdCwgc2hvdWxkIGJlIDAtMjNcbiAqIEByZXR1cm5zIGBwbWAgaWYgdGhlIGhvdXIgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEyLCBgYW1gIGlmIGxlc3MgdGhhbiAxMi5cbiAqL1xuY29uc3QgcGFyc2VBbVBtID0gKGhvdXIpID0+IHtcbiAgcmV0dXJuIGhvdXIgPj0gMTIgPyAncG0nIDogJ2FtJztcbn07XG4vKipcbiAqIFRha2VzIGEgbWF4IGRhdGUgc3RyaW5nIGFuZCBjcmVhdGVzIGEgRGF0ZXRpbWVQYXJ0c1xuICogb2JqZWN0LCBmaWxsaW5nIGluIGFueSBtaXNzaW5nIGluZm9ybWF0aW9uLlxuICogRm9yIGV4YW1wbGUsIG1heD1cIjIwMTJcIiB3b3VsZCBmaWxsIGluIHRoZSBtaXNzaW5nXG4gKiBtb250aCwgZGF5LCBob3VyLCBhbmQgbWludXRlIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCBwYXJzZU1heFBhcnRzID0gKG1heCwgdG9kYXlQYXJ0cykgPT4ge1xuICBjb25zdCB7IG1vbnRoLCBkYXksIHllYXIsIGhvdXIsIG1pbnV0ZSB9ID0gcGFyc2VEYXRlKG1heCk7XG4gIC8qKlxuICAgKiBXaGVuIHBhc3NpbmcgaW4gYG1heGAgb3IgYG1pbmAsIGRldmVsb3BlcnNcbiAgICogY2FuIHBhc3MgaW4gYW55IElTTy04NjAxIHN0cmluZy4gVGhpcyBtZWFuc1xuICAgKiB0aGF0IG5vdCBhbGwgb2YgdGhlIGRhdGUvdGltZSBmaWVsZHMgYXJlIGRlZmluZWQuXG4gICAqIEZvciBleGFtcGxlLCBwYXNzaW5nIG1heD1cIjIwMTJcIiBpcyB2YWxpZCBldmVuIHRob3VnaFxuICAgKiB0aGVyZSBpcyBubyBtb250aCwgZGF5LCBob3VyLCBvciBtaW51dGUgZGF0YS5cbiAgICogSG93ZXZlciwgYWxsIG9mIHRoaXMgZGF0YSBpcyByZXF1aXJlZCB3aGVuIGNsYW1waW5nIHRoZSBkYXRlXG4gICAqIHNvIHRoYXQgdGhlIGNvcnJlY3QgaW5pdGlhbCB2YWx1ZSBjYW4gYmUgc2VsZWN0ZWQuIEFzIGEgcmVzdWx0LFxuICAgKiB3ZSBuZWVkIHRvIGZpbGwgaW4gYW55IG9taXR0ZWQgZGF0YSB3aXRoIHRoZSBtaW4gb3IgbWF4IHZhbHVlcy5cbiAgICovXG4gIGNvbnN0IHllYXJWYWx1ZSA9IHllYXIgIT09IG51bGwgJiYgeWVhciAhPT0gdm9pZCAwID8geWVhciA6IHRvZGF5UGFydHMueWVhcjtcbiAgY29uc3QgbW9udGhWYWx1ZSA9IG1vbnRoICE9PSBudWxsICYmIG1vbnRoICE9PSB2b2lkIDAgPyBtb250aCA6IDEyO1xuICByZXR1cm4ge1xuICAgIG1vbnRoOiBtb250aFZhbHVlLFxuICAgIGRheTogZGF5ICE9PSBudWxsICYmIGRheSAhPT0gdm9pZCAwID8gZGF5IDogZ2V0TnVtRGF5c0luTW9udGgobW9udGhWYWx1ZSwgeWVhclZhbHVlKSxcbiAgICAvKipcbiAgICAgKiBQYXNzaW5nIGluIFwiSEg6bW1cIiBpcyBhIHZhbGlkIElTTy04NjAxXG4gICAgICogc3RyaW5nLCBzbyB3ZSBqdXN0IGRlZmF1bHQgdG8gdGhlIGN1cnJlbnQgeWVhclxuICAgICAqIGluIHRoaXMgY2FzZS5cbiAgICAgKi9cbiAgICB5ZWFyOiB5ZWFyVmFsdWUsXG4gICAgaG91cjogaG91ciAhPT0gbnVsbCAmJiBob3VyICE9PSB2b2lkIDAgPyBob3VyIDogMjMsXG4gICAgbWludXRlOiBtaW51dGUgIT09IG51bGwgJiYgbWludXRlICE9PSB2b2lkIDAgPyBtaW51dGUgOiA1OSxcbiAgfTtcbn07XG4vKipcbiAqIFRha2VzIGEgbWluIGRhdGUgc3RyaW5nIGFuZCBjcmVhdGVzIGEgRGF0ZXRpbWVQYXJ0c1xuICogb2JqZWN0LCBmaWxsaW5nIGluIGFueSBtaXNzaW5nIGluZm9ybWF0aW9uLlxuICogRm9yIGV4YW1wbGUsIG1pbj1cIjIwMTJcIiB3b3VsZCBmaWxsIGluIHRoZSBtaXNzaW5nXG4gKiBtb250aCwgZGF5LCBob3VyLCBhbmQgbWludXRlIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCBwYXJzZU1pblBhcnRzID0gKG1pbiwgdG9kYXlQYXJ0cykgPT4ge1xuICBjb25zdCB7IG1vbnRoLCBkYXksIHllYXIsIGhvdXIsIG1pbnV0ZSB9ID0gcGFyc2VEYXRlKG1pbik7XG4gIC8qKlxuICAgKiBXaGVuIHBhc3NpbmcgaW4gYG1heGAgb3IgYG1pbmAsIGRldmVsb3BlcnNcbiAgICogY2FuIHBhc3MgaW4gYW55IElTTy04NjAxIHN0cmluZy4gVGhpcyBtZWFuc1xuICAgKiB0aGF0IG5vdCBhbGwgb2YgdGhlIGRhdGUvdGltZSBmaWVsZHMgYXJlIGRlZmluZWQuXG4gICAqIEZvciBleGFtcGxlLCBwYXNzaW5nIG1heD1cIjIwMTJcIiBpcyB2YWxpZCBldmVuIHRob3VnaFxuICAgKiB0aGVyZSBpcyBubyBtb250aCwgZGF5LCBob3VyLCBvciBtaW51dGUgZGF0YS5cbiAgICogSG93ZXZlciwgYWxsIG9mIHRoaXMgZGF0YSBpcyByZXF1aXJlZCB3aGVuIGNsYW1waW5nIHRoZSBkYXRlXG4gICAqIHNvIHRoYXQgdGhlIGNvcnJlY3QgaW5pdGlhbCB2YWx1ZSBjYW4gYmUgc2VsZWN0ZWQuIEFzIGEgcmVzdWx0LFxuICAgKiB3ZSBuZWVkIHRvIGZpbGwgaW4gYW55IG9taXR0ZWQgZGF0YSB3aXRoIHRoZSBtaW4gb3IgbWF4IHZhbHVlcy5cbiAgICovXG4gIHJldHVybiB7XG4gICAgbW9udGg6IG1vbnRoICE9PSBudWxsICYmIG1vbnRoICE9PSB2b2lkIDAgPyBtb250aCA6IDEsXG4gICAgZGF5OiBkYXkgIT09IG51bGwgJiYgZGF5ICE9PSB2b2lkIDAgPyBkYXkgOiAxLFxuICAgIC8qKlxuICAgICAqIFBhc3NpbmcgaW4gXCJISDptbVwiIGlzIGEgdmFsaWQgSVNPLTg2MDFcbiAgICAgKiBzdHJpbmcsIHNvIHdlIGp1c3QgZGVmYXVsdCB0byB0aGUgY3VycmVudCB5ZWFyXG4gICAgICogaW4gdGhpcyBjYXNlLlxuICAgICAqL1xuICAgIHllYXI6IHllYXIgIT09IG51bGwgJiYgeWVhciAhPT0gdm9pZCAwID8geWVhciA6IHRvZGF5UGFydHMueWVhcixcbiAgICBob3VyOiBob3VyICE9PSBudWxsICYmIGhvdXIgIT09IHZvaWQgMCA/IGhvdXIgOiAwLFxuICAgIG1pbnV0ZTogbWludXRlICE9PSBudWxsICYmIG1pbnV0ZSAhPT0gdm9pZCAwID8gbWludXRlIDogMCxcbiAgfTtcbn07XG5cbmV4cG9ydCB7IGdldFllYXJDb2x1bW5EYXRhIGFzIEEsIGlzTW9udGhGaXJzdExvY2FsZSBhcyBCLCBnZXRUaW1lQ29sdW1uc0RhdGEgYXMgQywgaXNMb2NhbGVEYXlQZXJpb2RSVEwgYXMgRCwgZ2V0RGF5c09mV2VlayBhcyBFLCBnZXRNb250aEFuZFllYXIgYXMgRiwgZ2V0RGF5c09mTW9udGggYXMgRywgZ2VuZXJhdGVNb250aHMgYXMgSCwgaXMyNEhvdXIgYXMgSSwgZ2V0TG9jYWxpemVkVGltZSBhcyBKLCBnZXRNb250aEFuZERheSBhcyBLLCBmb3JtYXRWYWx1ZSBhcyBMLCBnZXROZXh0WWVhciBhcyBNLCBnZXRQcmV2aW91c1llYXIgYXMgTiwgY2xhbXBEYXRlIGFzIE8sIHBhcnNlQW1QbSBhcyBQLCBjYWxjdWxhdGVIb3VyRnJvbUFNUE0gYXMgUSwgZ2V0TG9jYWxpemVkRGF0ZVRpbWUgYXMgUiwgZ2V0TW9udGhEYXlBbmRZZWFyIGFzIFMsIGdldERheSBhcyBhLCBpc0FmdGVyIGFzIGIsIGlzU2FtZURheSBhcyBjLCBnZXRQcmV2aW91c01vbnRoIGFzIGQsIGdldE5leHRNb250aCBhcyBlLCBnZXRUb2RheSBhcyBmLCBnZW5lcmF0ZURheUFyaWFMYWJlbCBhcyBnLCBnZXRQYXJ0c0Zyb21DYWxlbmRhckRheSBhcyBoLCBpc0JlZm9yZSBhcyBpLCBnZXRFbmRPZldlZWsgYXMgaiwgZ2V0U3RhcnRPZldlZWsgYXMgaywgZ2V0UHJldmlvdXNEYXkgYXMgbCwgZ2V0TmV4dERheSBhcyBtLCBnZXRQcmV2aW91c1dlZWsgYXMgbiwgZ2V0TmV4dFdlZWsgYXMgbywgcGFyc2VEYXRlIGFzIHAsIHBhcnNlTWluUGFydHMgYXMgcSwgcGFyc2VNYXhQYXJ0cyBhcyByLCBjb252ZXJ0VG9BcnJheU9mTnVtYmVycyBhcyBzLCBjb252ZXJ0RGF0YVRvSVNPIGFzIHQsIGdldE51bURheXNJbk1vbnRoIGFzIHUsIHZhbGlkYXRlUGFydHMgYXMgdiwgd2FybklmVmFsdWVPdXRPZkJvdW5kcyBhcyB3LCBnZXRDb21iaW5lZERhdGVDb2x1bW5EYXRhIGFzIHgsIGdldE1vbnRoQ29sdW1uRGF0YSBhcyB5LCBnZXREYXlDb2x1bW5EYXRhIGFzIHogfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5jb25zdCBob3N0Q29udGV4dCA9IChzZWxlY3RvciwgZWwpID0+IHtcbiAgcmV0dXJuIGVsLmNsb3Nlc3Qoc2VsZWN0b3IpICE9PSBudWxsO1xufTtcbi8qKlxuICogQ3JlYXRlIHRoZSBtb2RlIGFuZCBjb2xvciBjbGFzc2VzIGZvciB0aGUgY29tcG9uZW50IGJhc2VkIG9uIHRoZSBjbGFzc2VzIHBhc3NlZCBpblxuICovXG5jb25zdCBjcmVhdGVDb2xvckNsYXNzZXMgPSAoY29sb3IsIGNzc0NsYXNzTWFwKSA9PiB7XG4gIHJldHVybiB0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnICYmIGNvbG9yLmxlbmd0aCA+IDBcbiAgICA/IE9iamVjdC5hc3NpZ24oeyAnaW9uLWNvbG9yJzogdHJ1ZSwgW2Bpb24tY29sb3ItJHtjb2xvcn1gXTogdHJ1ZSB9LCBjc3NDbGFzc01hcCkgOiBjc3NDbGFzc01hcDtcbn07XG5jb25zdCBnZXRDbGFzc0xpc3QgPSAoY2xhc3NlcykgPT4ge1xuICBpZiAoY2xhc3NlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgYXJyYXkgPSBBcnJheS5pc0FycmF5KGNsYXNzZXMpID8gY2xhc3NlcyA6IGNsYXNzZXMuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4gYXJyYXlcbiAgICAgIC5maWx0ZXIoKGMpID0+IGMgIT0gbnVsbClcbiAgICAgIC5tYXAoKGMpID0+IGMudHJpbSgpKVxuICAgICAgLmZpbHRlcigoYykgPT4gYyAhPT0gJycpO1xuICB9XG4gIHJldHVybiBbXTtcbn07XG5jb25zdCBnZXRDbGFzc01hcCA9IChjbGFzc2VzKSA9PiB7XG4gIGNvbnN0IG1hcCA9IHt9O1xuICBnZXRDbGFzc0xpc3QoY2xhc3NlcykuZm9yRWFjaCgoYykgPT4gKG1hcFtjXSA9IHRydWUpKTtcbiAgcmV0dXJuIG1hcDtcbn07XG5jb25zdCBTQ0hFTUUgPSAvXlthLXpdW2EtejAtOStcXC0uXSo6LztcbmNvbnN0IG9wZW5VUkwgPSBhc3luYyAodXJsLCBldiwgZGlyZWN0aW9uLCBhbmltYXRpb24pID0+IHtcbiAgaWYgKHVybCAhPSBudWxsICYmIHVybFswXSAhPT0gJyMnICYmICFTQ0hFTUUudGVzdCh1cmwpKSB7XG4gICAgY29uc3Qgcm91dGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW9uLXJvdXRlcicpO1xuICAgIGlmIChyb3V0ZXIpIHtcbiAgICAgIGlmIChldiAhPSBudWxsKSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm91dGVyLnB1c2godXJsLCBkaXJlY3Rpb24sIGFuaW1hdGlvbik7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZUNvbG9yQ2xhc3NlcyBhcyBjLCBnZXRDbGFzc01hcCBhcyBnLCBob3N0Q29udGV4dCBhcyBoLCBvcGVuVVJMIGFzIG8gfTtcbiJdLCJuYW1lcyI6WyJwcmludElvbldhcm5pbmciLCJtZXNzYWdlIiwicGFyYW1zIiwiY29uc29sZSIsIndhcm4iLCJwcmludElvbkVycm9yIiwiZXJyb3IiLCJwcmludFJlcXVpcmVkRWxlbWVudEVycm9yIiwiZWwiLCJ0YXJnZXRTZWxlY3RvcnMiLCJ0YWdOYW1lIiwidG9Mb3dlckNhc2UiLCJqb2luIiwiYSIsImIiLCJwIiwiaXNTYW1lRGF5IiwiYmFzZVBhcnRzIiwiY29tcGFyZVBhcnRzIiwibW9udGgiLCJkYXkiLCJ5ZWFyIiwiaXNCZWZvcmUiLCJpc0FmdGVyIiwid2FybklmVmFsdWVPdXRPZkJvdW5kcyIsInZhbHVlIiwibWluIiwibWF4IiwidmFsdWVBcnJheSIsIkFycmF5IiwiaXNBcnJheSIsInZhbCIsInVuZGVmaW5lZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJpc0xlYXBZZWFyIiwiaXMyNEhvdXIiLCJsb2NhbGUiLCJob3VyQ3ljbGUiLCJmb3JtYXR0ZWQiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJob3VyIiwib3B0aW9ucyIsInJlc29sdmVkT3B0aW9ucyIsImRhdGUiLCJEYXRlIiwicGFydHMiLCJmb3JtYXRUb1BhcnRzIiwiZmluZCIsInR5cGUiLCJFcnJvciIsImdldE51bURheXNJbk1vbnRoIiwiaXNNb250aEZpcnN0TG9jYWxlIiwiZm9ybWF0T3B0aW9ucyIsImlzTG9jYWxlRGF5UGVyaW9kUlRMIiwidHdvRGlnaXQiLCJNYXRoIiwiYWJzIiwic2xpY2UiLCJmb3VyRGlnaXQiLCJjb252ZXJ0RGF0YVRvSVNPIiwiZGF0YSIsIm1hcCIsInJ0biIsIm1pbnV0ZSIsInR6T2Zmc2V0IiwiZmxvb3IiLCJjb252ZXJ0MTJIb3VyVG8yNEhvdXIiLCJhbXBtIiwiZ2V0U3RhcnRPZldlZWsiLCJyZWZQYXJ0cyIsImRheU9mV2VlayIsInN1YnRyYWN0RGF5cyIsImdldEVuZE9mV2VlayIsImFkZERheXMiLCJnZXROZXh0RGF5IiwiZ2V0UHJldmlvdXNEYXkiLCJnZXRQcmV2aW91c1dlZWsiLCJnZXROZXh0V2VlayIsIm51bURheXMiLCJ3b3JraW5nUGFydHMiLCJkYXlzSW5Nb250aCIsImdldFByZXZpb3VzTW9udGgiLCJudW1EYXlzSW5Nb250aCIsImdldE5leHRNb250aCIsImNoYW5nZVllYXIiLCJ5ZWFyRGVsdGEiLCJnZXRQcmV2aW91c1llYXIiLCJnZXROZXh0WWVhciIsImdldEludGVybmFsSG91clZhbHVlIiwidXNlMjRIb3VyIiwiY2FsY3VsYXRlSG91ckZyb21BTVBNIiwiY3VycmVudFBhcnRzIiwibmV3QU1QTSIsImN1cnJlbnRBTVBNIiwibmV3SG91ciIsInZhbGlkYXRlUGFydHMiLCJwYXJ0c0NvcHkiLCJPYmplY3QiLCJhc3NpZ24iLCJnZXRGb3JtYXR0ZWREYXlQZXJpb2QiLCJkYXlQZXJpb2QiLCJ0b1VwcGVyQ2FzZSIsImdldExvY2FsaXplZFRpbWUiLCJ0aW1lWm9uZSIsImZvcm1hdCIsImFkZFRpbWVQYWRkaW5nIiwidmFsdWVUb1N0cmluZyIsInRvU3RyaW5nIiwibGVuZ3RoIiwiZ2V0Rm9ybWF0dGVkSG91ciIsImdlbmVyYXRlRGF5QXJpYUxhYmVsIiwidG9kYXkiLCJsYWJlbFN0cmluZyIsIndlZWtkYXkiLCJnZXRNb250aEFuZERheSIsImdldE1vbnRoQW5kWWVhciIsImdldE1vbnRoRGF5QW5kWWVhciIsImdldExvY2FsaXplZERhdGVUaW1lIiwiZ2V0RGF5IiwiZ2V0TG9jYWxpemVkRGF0ZVRpbWVQYXJ0cyIsIm9iaiIsImdldFllYXIiLCJnZXROb3JtYWxpemVkRGF0ZSIsInRpbWVTdHJpbmciLCJnZXREYXRlVGltZUZvcm1hdCIsImdldFRvZGF5TGFiZWwiLCJsYWJlbCIsIlJlbGF0aXZlVGltZUZvcm1hdCIsIm51bWVyaWMiLCJjaGFyQXQiLCJyZW1vdmVEYXRlVHpPZmZzZXQiLCJnZXRUaW1lem9uZU9mZnNldCIsInNldE1pbnV0ZXMiLCJnZXRNaW51dGVzIiwiREFURV9BTSIsIkRBVEVfUE0iLCJnZXRMb2NhbGl6ZWREYXlQZXJpb2QiLCJsb2NhbGl6ZWREYXlQZXJpb2QiLCJwYXJ0IiwiZm9ybWF0VmFsdWUiLCJnZXRUb2RheSIsInRvSVNPU3RyaW5nIiwibWludXRlcyIsImhvdXIxMiIsImhvdXIyMyIsImdldERheXNPZldlZWsiLCJtb2RlIiwiZmlyc3REYXlPZldlZWsiLCJ3ZWVrZGF5Rm9ybWF0IiwiaW50bCIsInN0YXJ0RGF0ZSIsImRheXNPZldlZWsiLCJpIiwiY3VycmVudERhdGUiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsInB1c2giLCJnZXREYXlzT2ZNb250aCIsImZpcnN0T2ZNb250aCIsIm9mZnNldCIsImRheXMiLCJnZW5lcmF0ZVRpbWUiLCJtaW5QYXJ0cyIsIm1heFBhcnRzIiwiaG91clZhbHVlcyIsIm1pbnV0ZVZhbHVlcyIsInByb2Nlc3NlZEhvdXJzIiwicHJvY2Vzc2VkTWludXRlcyIsImlzQU1BbGxvd2VkIiwiaXNQTUFsbG93ZWQiLCJmaWx0ZXIiLCJpbmNsdWRlcyIsImNvbnZlcnRlZEhvdXIiLCJpc1Bhc3RNaW5Ib3VyIiwiaG91cnMiLCJhbSIsInBtIiwiZ2VuZXJhdGVNb250aHMiLCJnZXRNb250aENvbHVtbkRhdGEiLCJtb250aFZhbHVlcyIsIm1vbnRocyIsInByb2Nlc3NlZE1vbnRocyIsImZvckVhY2giLCJwcm9jZXNzZWRNb250aCIsIm1vbnRoU3RyaW5nIiwidGV4dCIsIm1heE1vbnRoIiwibWluTW9udGgiLCJnZXREYXlDb2x1bW5EYXRhIiwiZGF5VmFsdWVzIiwibWF4RGF5IiwibWluRGF5IiwicHJvY2Vzc2VkRGF5cyIsInByb2Nlc3NlZERheSIsImRheVN0cmluZyIsImdldFllYXJDb2x1bW5EYXRhIiwieWVhclZhbHVlcyIsIl9hIiwiX2IiLCJwcm9jZXNzZWRZZWFycyIsIm1heFllYXIiLCJtaW5ZZWFyIiwiZ2V0QWxsTW9udGhzSW5SYW5nZSIsImdldENvbWJpbmVkRGF0ZUNvbHVtbkRhdGEiLCJ0b2RheVBhcnRzIiwiaXRlbXMiLCJtb250aE9iamVjdCIsInJlZmVyZW5jZU1vbnRoIiwibW9udGhEYXlzIiwiZGF0ZVBhcnRzIiwiZGF0ZUNvbHVtbkl0ZW1zIiwiZGF5T2JqZWN0IiwiaXNUb2RheSIsImdldFRpbWVDb2x1bW5zRGF0YSIsImFsbG93ZWRIb3VyVmFsdWVzIiwiYWxsb3dlZE1pbnV0ZVZhdWVzIiwiaG91cnNJdGVtcyIsIm1pbnV0ZXNJdGVtcyIsImRheVBlcmlvZEl0ZW1zIiwibWludXRlc0RhdGEiLCJob3Vyc0RhdGEiLCJkYXlQZXJpb2REYXRhIiwiSVNPXzg2MDFfUkVHRVhQIiwiVElNRV9SRUdFWFAiLCJjb252ZXJ0VG9BcnJheU9mTnVtYmVycyIsImlucHV0IiwicHJvY2Vzc2VkSW5wdXQiLCJyZXBsYWNlIiwic3BsaXQiLCJ2YWx1ZXMiLCJudW0iLCJwYXJzZUludCIsImlzRmluaXRlIiwiZ2V0UGFydHNGcm9tQ2FsZW5kYXJEYXkiLCJnZXRBdHRyaWJ1dGUiLCJwYXJzZURhdGUiLCJ2YWxTdHIiLCJwYXJzZSIsImV4ZWMiLCJ1bnNoaWZ0IiwiY2xhbXBEYXRlIiwicGFyc2VBbVBtIiwicGFyc2VNYXhQYXJ0cyIsInllYXJWYWx1ZSIsIm1vbnRoVmFsdWUiLCJwYXJzZU1pblBhcnRzIiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiRyIsIkgiLCJJIiwiSiIsIksiLCJMIiwiTSIsIk4iLCJPIiwiUCIsIlEiLCJSIiwiUyIsImMiLCJkIiwiZSIsImYiLCJnIiwiaCIsImoiLCJrIiwibCIsIm0iLCJuIiwibyIsInEiLCJyIiwicyIsInQiLCJ1IiwidiIsInciLCJ4IiwieSIsInoiLCJob3N0Q29udGV4dCIsInNlbGVjdG9yIiwiY2xvc2VzdCIsImNyZWF0ZUNvbG9yQ2xhc3NlcyIsImNvbG9yIiwiY3NzQ2xhc3NNYXAiLCJnZXRDbGFzc0xpc3QiLCJjbGFzc2VzIiwiYXJyYXkiLCJ0cmltIiwiZ2V0Q2xhc3NNYXAiLCJTQ0hFTUUiLCJvcGVuVVJMIiwidXJsIiwiZXYiLCJkaXJlY3Rpb24iLCJhbmltYXRpb24iLCJ0ZXN0Iiwicm91dGVyIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwicHJldmVudERlZmF1bHQiXSwic291cmNlUm9vdCI6IndlYnBhY2s6Ly8vIiwieF9nb29nbGVfaWdub3JlTGlzdCI6WzAsMSwyXX0=